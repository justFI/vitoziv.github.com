<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[VITO]]></title>
  <link href="http://vit0.com/atom.xml" rel="self"/>
  <link href="http://vit0.com/"/>
  <updated>2015-01-27T11:07:26+08:00</updated>
  <id>http://vit0.com/</id>
  <author>
    <name><![CDATA[Vito Zhang]]></name>
    <email><![CDATA[vvitozhang@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS UITextView 输入内容实时更新 Cell 的高度]]></title>
    <link href="http://vit0.com/blog/2014/12/25/ios-textview-in-cell/"/>
    <updated>2014-12-25T21:37:00+08:00</updated>
    <id>http://vit0.com/blog/2014/12/25/ios-textview-in-cell</id>
    <content type="html"><![CDATA[<p>这篇文章介绍了在一个动态数据的 table view 中，cell 根据 text view 内容的输入实时改变 cell 和 table view 的高度。自动计算 cell 高度的功能使用 iOS 8 才支持的自适应 cell，如果你还不知道 iOS 8 自适应 cell，可以参看这篇文章：<a href="http://vit0.com/blog/2014/11/13/ios-8-zi-shi-ying-cell/">iOS 8 自适应 Cell</a></p>

<p>先上图，我们最终要实现的效果是这样的：</p>

<p><img src="http://vit0.com/images/posts/2014-12-25-text-view-in-cell.gif" alt="image" /></p>

<p><em>图 1：实时更新 cell 高度</em></p>

<p><strong> 实现上面效果的基本原理是： </strong></p>

<ol>
<li>在 cell 中设置好 text view 的 autolayout，让 cell 可以根据内容自适应大小</li>
<li>text view 中输入内容，根据内容更新 textView 的高度</li>
<li>调用 tableView 的 beginUpdates 和 endUpdates，重新计算 cell 的高度</li>
<li>将 text view 更新后的数据保存，以免 table view 滚动超过一屏再滚回来 text view 中的数据又不刷新成原来的数据了。</li>
</ol>


<h2>功能具体实现方法</h2>

<p>新建一个项目，拉出 TableViewController，在 cell 上添加一个 UITextView。</p>

<p>首先设置 text view 的 autolayout，比较关键的 constraint 是要设置 textView 的高度<strong>大于等于</strong>一个值。如图：</p>

<p><img src="http://vit0.com/images/posts/2014-12-25-autolayout-setting.jpg" alt="image" /></p>

<p><em>图 2： Text view 的 autolayout 设置</em></p>

<p>然后，设置 UITextView 的 scrollEnable 为 NO。这一点很关键，如果不设置为 NO，UITextView  在内容超出 frame 后，重新设置 text view 的高度会失效，并出现滚动条。</p>

<p><img src="http://vit0.com/images/posts/2014-12-25-uncheck-scroll-enable.jpg" alt="image" /></p>

<p><em>图 3：去掉 scrolling enable 勾选</em></p>

<p>根据刚才在 storyboard 中创建的 cell，新建一个 UITableViewCell 类。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#import &lt;UIKit/UIKit.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@interface</span> <span class="nc">TextViewCell</span> : <span class="bp">UITableViewCell</span>
</span><span class='line'>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">weak</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="kt">IBOutlet</span> <span class="bp">UITextView</span> <span class="o">*</span><span class="n">textView</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>创建 TableViewController 并初始化一些数据</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#import &quot;TableViewController.h&quot;</span>
</span><span class='line'><span class="cp">#import &quot;TextViewCell.h&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@interface</span> <span class="nc">TableViewController</span> <span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">)</span> <span class="bp">NSArray</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">TableViewController</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span> <span class="p">{</span>
</span><span class='line'>  <span class="p">[</span><span class="nb">super</span> <span class="n">viewDidLoad</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">//  支持自适应 cell</span>
</span><span class='line'>  <span class="nb">self</span><span class="p">.</span><span class="n">tableView</span><span class="p">.</span><span class="n">estimatedRowHeight</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
</span><span class='line'>  <span class="nb">self</span><span class="p">.</span><span class="n">tableView</span><span class="p">.</span><span class="n">rowHeight</span> <span class="o">=</span> <span class="n">UITableViewAutomaticDimension</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="nb">self</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="l">@[</span><span class="s">@&quot;Cell 1 &quot;</span><span class="p">,</span> <span class="s">@&quot;Cell 2&quot;</span><span class="p">,</span> <span class="s">@&quot;Cell 3&quot;</span><span class="p">,</span> <span class="s">@&quot;Cell 4&quot;</span><span class="p">,</span> <span class="s">@&quot;Cell 5&quot;</span><span class="p">,</span> <span class="s">@&quot;Cell 6&quot;</span><span class="p">,</span> <span class="s">@&quot;Cell 7&quot;</span><span class="p">,</span> <span class="s">@&quot;Cell 8&quot;</span><span class="l">]</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#pragma mark - Table view data source</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">NSInteger</span><span class="p">)</span><span class="nf">tableView:</span><span class="p">(</span><span class="bp">UITableView</span> <span class="o">*</span><span class="p">)</span><span class="nv">tableView</span> <span class="nf">numberOfRowsInSection:</span><span class="p">(</span><span class="bp">NSInteger</span><span class="p">)</span><span class="nv">section</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">data</span> <span class="n">count</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">UITableViewCell</span> <span class="o">*</span><span class="p">)</span><span class="nf">tableView:</span><span class="p">(</span><span class="bp">UITableView</span> <span class="o">*</span><span class="p">)</span><span class="nv">tableView</span> <span class="nf">cellForRowAtIndexPath:</span><span class="p">(</span><span class="bp">NSIndexPath</span> <span class="o">*</span><span class="p">)</span><span class="nv">indexPath</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">TextViewCell</span> <span class="o">*</span><span class="n">cell</span> <span class="o">=</span> <span class="p">[</span><span class="n">tableView</span> <span class="nl">dequeueReusableCellWithIdentifier</span><span class="p">:</span><span class="s">@&quot;TextViewCell&quot;</span> <span class="nl">forIndexPath</span><span class="p">:</span><span class="n">indexPath</span><span class="p">];</span>
</span><span class='line'>  <span class="n">cell</span><span class="p">.</span><span class="n">textView</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">indexPath</span><span class="p">.</span><span class="n">row</span><span class="p">];</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">cell</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用上面的代码项目已经可以运行了，但是 text view 还不能自动更新大小，下面来实现 text view 根据内容计算高度</p>

<p>先在 storyboard 中，将 UITextView 的 delegate 设置为 cell</p>

<p><img src="http://vit0.com/images/posts/2014-12-25-set-delegate.jpg" alt="image" /></p>

<p><em>图 4：设置 UITextView 的 delegate 为 cell</em></p>

<p>在 <code>TextViewCell.m</code> 中实现 <code>- (void)textViewDidChange:(UITextView *)textView</code>，每次 text view 内容改变的时候，就重新计算一次 text view 的大小，并让 table view 更新高度。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#import &quot;TextViewCell.h&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">TextViewCell</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">textViewDidChange:</span><span class="p">(</span><span class="bp">UITextView</span> <span class="o">*</span><span class="p">)</span><span class="nv">textView</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="bp">CGRect</span> <span class="n">bounds</span> <span class="o">=</span> <span class="n">textView</span><span class="p">.</span><span class="n">bounds</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 计算 text view 的高度</span>
</span><span class='line'>  <span class="bp">CGSize</span> <span class="n">maxSize</span> <span class="o">=</span> <span class="n">CGSizeMake</span><span class="p">(</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">CGFLOAT_MAX</span><span class="p">);</span>
</span><span class='line'>  <span class="bp">CGSize</span> <span class="n">newSize</span> <span class="o">=</span> <span class="p">[</span><span class="n">textView</span> <span class="nl">sizeThatFits</span><span class="p">:</span><span class="n">maxSize</span><span class="p">];</span>
</span><span class='line'>  <span class="n">bounds</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">newSize</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">textView</span><span class="p">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 让 table view 重新计算高度</span>
</span><span class='line'>  <span class="bp">UITableView</span> <span class="o">*</span><span class="n">tableView</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="n">tableView</span><span class="p">];</span>
</span><span class='line'>  <span class="p">[</span><span class="n">tableView</span> <span class="n">beginUpdates</span><span class="p">];</span>
</span><span class='line'>  <span class="p">[</span><span class="n">tableView</span> <span class="n">endUpdates</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">UITableView</span> <span class="o">*</span><span class="p">)</span><span class="nf">tableView</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="bp">UIView</span> <span class="o">*</span><span class="n">tableView</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">superview</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">[</span><span class="n">tableView</span> <span class="nl">isKindOfClass</span><span class="p">:[</span><span class="bp">UITableView</span> <span class="k">class</span><span class="p">]]</span> <span class="o">&amp;&amp;</span> <span class="n">tableView</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">tableView</span> <span class="o">=</span> <span class="n">tableView</span><span class="p">.</span><span class="n">superview</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="p">(</span><span class="bp">UITableView</span> <span class="o">*</span><span class="p">)</span><span class="n">tableView</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样就已经实现了 text view 改变内容自动更新 cell 高度的功能，这篇文章没有涉及到计算 cell 高度的代码，因为计算 cell 高度的工作全部交给 iOS 8 的 autolayout 自动计算了，这让我们少写了许多令人痛苦的代码。</p>

<p><strong>最后：</strong>为了防止 table view 过长，导致滚动后重新加载 cell，会让 text view 中的内容还原的问题，我们应该在更新了 text view 的内容之后保存数据。（如果是在编辑状态下，还需要考虑取消编辑后的回滚功能。 普通数组数据，可以保存一个原始数据的副本，如果用户取消编辑，就设置 data 为原始数据的副本。如果是 NSManagedObject 对象可以使用 NSUndoManage，不过这些已经超出本篇文章的内容范围了。）</p>

<p>为了在 text view 更新后能让 TableViewController 中的 data 更新，需要为 cell 添加一个 delegate，在 text view 更新后调用 delegate，TableViewController 中收到 delegate 信息后更新 data。</p>

<p>修改后的 <code>TextViewCell.h</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#import &lt;UIKit/UIKit.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@protocol</span> <span class="nc">TextViewCellDelegate</span>;
</span><span class='line'>
</span><span class='line'><span class="k">@interface</span> <span class="nc">TextViewCell</span> : <span class="bp">UITableViewCell</span>
</span><span class='line'>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">weak</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="kt">IBOutlet</span> <span class="bp">UITextView</span> <span class="o">*</span><span class="n">textView</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">weak</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="kt">id</span><span class="o">&lt;</span><span class="n">TextViewCellDelegate</span><span class="o">&gt;</span> <span class="n">delegate</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@protocol</span> <span class="nc">TextViewCellDelegate</span> <span class="o">&lt;</span><span class="bp">NSObject</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">textViewCell</span><span class="p">:(</span><span class="n">TextViewCell</span> <span class="o">*</span><span class="p">)</span><span class="n">cell</span> <span class="nl">didChangeText</span><span class="p">:(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">text</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>在 <code>TextView.m</code>的 <code>- (void)textViewDidChange:(UITextView *)textView</code>  中添加 delegate 的调用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">textViewDidChange:</span><span class="p">(</span><span class="bp">UITextView</span> <span class="o">*</span><span class="p">)</span><span class="nv">textView</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">([</span><span class="nb">self</span><span class="p">.</span><span class="n">delegate</span> <span class="nl">respondsToSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">textViewCell</span><span class="p">:</span><span class="nl">didChangeText</span><span class="p">:)])</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">delegate</span> <span class="nl">textViewCell</span><span class="p">:</span><span class="nb">self</span> <span class="nl">didChangeText</span><span class="p">:</span><span class="n">textView</span><span class="p">.</span><span class="n">text</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 计算 text view 的高度</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'>  <span class="c1">// 让 table view 重新计算高度</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后在 <code>TableViewController.m</code> 的最后实现 <code>TextViewCellDelegate</code> 的方法，更新 data</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#pragma mark - TextViewCellDelegate</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">textViewCell:</span><span class="p">(</span><span class="n">TextViewCell</span> <span class="o">*</span><span class="p">)</span><span class="nv">cell</span> <span class="nf">didChangeText:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">text</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="bp">NSIndexPath</span> <span class="o">*</span><span class="n">indexPath</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">tableView</span> <span class="nl">indexPathForCell</span><span class="p">:</span><span class="n">cell</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>  <span class="bp">NSMutableArray</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">data</span> <span class="n">mutableCopy</span><span class="p">];</span>
</span><span class='line'>  <span class="n">data</span><span class="p">[</span><span class="n">indexPath</span><span class="p">.</span><span class="n">row</span><span class="p">]</span> <span class="o">=</span> <span class="n">text</span><span class="p">;</span>
</span><span class='line'>  <span class="nb">self</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span> <span class="k">copy</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>总结</h2>

<p>从最后的代码量来看，这个功能在实现上并不难。只要记住的几点：</p>

<ol>
<li>使用 iOS 8 的特性自动计算 cell 高度，或者在 heightForRow 中自己实现计算高度的代码。</li>
<li>UITextView 的 scrollEnable 要设置 NO</li>
<li>更新 table view 的高度使用 beginUpdates 和 endUpdates</li>
<li>Text view 更新内容后要保存数据，以免重新加载 cell 时数据丢失</li>
</ol>


<h2>参考</h2>

<ul>
<li><a href="https://pontifex.azurewebsites.net/self-sizing-uitableviewcell-with-uitextview-in-ios-8">https://pontifex.azurewebsites.net/self-sizing-uitableviewcell-with-uitextview-in-ios-8/</a></li>
<li><a href="http://stackoverflow.com/questions/50467/how-do-i-size-a-uitextview-to-its-content/26599389#26599389">http://stackoverflow.com/questions/50467/how-do-i-size-a-uitextview-to-its-content/26599389#26599389</a></li>
<li><a href="http://stackoverflow.com/questions/18368567/uitableviewcell-with-uitextview-height-in-ios-7">http://stackoverflow.com/questions/18368567/uitableviewcell-with-uitextview-height-in-ios-7</a></li>
<li><a href="http://stackoverflow.com/questions/460014/can-you-animate-a-height-change-on-a-uitableviewcell-when-selected">http://stackoverflow.com/questions/460014/can-you-animate-a-height-change-on-a-uitableviewcell-when-selected</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 8 自适应 Cell]]></title>
    <link href="http://vit0.com/blog/2014/11/13/ios-8-zi-shi-ying-cell/"/>
    <updated>2014-11-13T23:37:00+08:00</updated>
    <id>http://vit0.com/blog/2014/11/13/ios-8-zi-shi-ying-cell</id>
    <content type="html"><![CDATA[<p>在使用 table view 的时侯经常会遇到这样的需求：table view 的 cell 中的内容是动态的，导致在开发的时候不知道一个 cell 的高度具体是多少，所以需要提供一个计算 cell 高度的算法，在每次加载到这个 cell 的时候计算出 cell 真正的高度。</p>

<h2>在 iOS 8 之前</h2>

<p>没有使用 Autolayout 的情况下，需要实现 table view delegate 的 <code>tableView(tableView: UITableView, heightForRowAtIndexPath indexPath: NSIndexPath) -&gt; CGFloat</code>  方法，在这个方法中计算并返回 cell 的高度。比如，我有一个可以显示任意行数的纯文本 cell，计算 cell 的代码可以是这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="kr">override</span> <span class="k">func</span> <span class="n">tableView</span><span class="p">(</span><span class="nl">tableView</span><span class="p">:</span> <span class="bp">UITableView</span><span class="p">,</span> <span class="n">heightForRowAtIndexPath</span> <span class="nl">indexPath</span><span class="p">:</span> <span class="bp">NSIndexPath</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">CGFloat</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">let</span> <span class="n">content</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">datas</span><span class="p">[</span><span class="n">indexPath</span><span class="p">.</span><span class="n">row</span><span class="p">]</span> <span class="kt">as</span> <span class="n">String</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">let</span> <span class="nl">padding</span><span class="p">:</span> <span class="n">CGFloat</span> <span class="o">=</span> <span class="mi">20</span>
</span><span class='line'>    <span class="k">let</span> <span class="n">width</span> <span class="o">=</span> <span class="n">tableView</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">-</span> <span class="n">padding</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">let</span> <span class="n">size</span> <span class="o">=</span> <span class="n">CGSizeMake</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">CGFloat</span><span class="p">.</span><span class="n">max</span><span class="p">)</span>
</span><span class='line'>    <span class="k">let</span> <span class="n">attributes</span> <span class="o">=</span> <span class="p">[</span><span class="nl">NSFontAttributeName</span><span class="p">:</span> <span class="bp">UIFont</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;Helvetica&quot;</span><span class="p">,</span> <span class="nl">size</span><span class="p">:</span> <span class="mi">14</span><span class="p">)</span><span class="o">!</span><span class="p">]</span>
</span><span class='line'>    <span class="k">let</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">content</span><span class="p">.</span><span class="n">boundingRectWithSize</span><span class="p">(</span><span class="n">size</span><span class="p">,</span>
</span><span class='line'>        <span class="nl">options</span><span class="p">:</span> <span class="n">NSStringDrawingOptions</span><span class="p">.</span><span class="n">UsesLineFragmentOrigin</span><span class="p">,</span>
</span><span class='line'>        <span class="nl">attributes</span><span class="p">:</span> <span class="n">attributes</span><span class="p">,</span>
</span><span class='line'>        <span class="nl">context</span><span class="p">:</span> <span class="nb">nil</span><span class="p">)</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">frame</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码是一个最简单的例子，这个例子看起来好像没有什么问题。但是通过查看这个 delegate 方法的文档后，可以知道，在每次 reload tableview 的时候，程序会先计算出每一个 cell 的高度，等所有高度计算完毕，确定了 tableview 的总的高度后，才开始渲染视图并显示在屏幕上。这意味着在显示 table view 之前需要执行一堆的计算，并且这是在主线程中进行的，如果计算量太大程序就很有可能出现卡顿感。比如： table view 的数据有上千条，或者计算高度的代码中还要先获取图片再根据图片计算高度，这些操作都是非常慢的。</p>

<p>如果在 cell 中使用了 autolayout，在计算 cell 高度时会更麻烦。有兴趣的可以看这里有篇关于<a href="http://johnszumski.com/blog/auto-layout-for-table-view-cells-with-dynamic-heights">如何在 autolayout 下动态计算高度</a> 的文章。</p>

<p>为什么不能等滚动到某个 cell 的时候，再调用计算这个 cell 高度的 delegate 呢？原因是 tableview 需要获得它的内容的总高度，用这个高度去确定滚动条的大小等。直到 iOS 7 <code>UITableViewDelegate</code>中添加了新的 API</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="n">tableView</span><span class="p">(</span><span class="nl">tableView</span><span class="p">:</span> <span class="bp">UITableView</span><span class="p">,</span> <span class="n">estimatedHeightForRowAtIndexPath</span> <span class="nl">indexPath</span><span class="p">:</span> <span class="bp">NSIndexPath</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">CGFloat</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个方法用于返回一个 cell 的预估高度，如果在程序中实现了这个方法，tableview 首次加载的时候就不会调用<code>heightForRowAtIndexPath</code> 方法，而是用 <code>estimatedHeightForRowAtIndexPath</code>  返回的预估高度计算 tableview 的总高度，然后 tableview 就可以显示出来了，等到 cell 可见的时候，再去调用<code>heightForRowAtIndexPath</code> 获取 cell 的正确高度。</p>

<p>通过使用<code>estimatedHeightForRowAtIndexPath</code> 这个 Delegate 方法，解决了首次加载 table view 出现的性能问题。但还有一个麻烦的问题，就是在 cell 没有被加载的时候计算 cell 的高度，上面给出的代码中，仅仅是计算一个 NSString 的高度，就需要不少代码了。这种计算实际上是必须的，然而在 iOS 8 开始，你可能可以不用再写这些烦人的计算代码了！</p>

<h2>iOS 8 的魔法</h2>

<p>在 iOS 8 中，self size cell 提供了这样一种机制：cell 如果有一个确定的宽度/高度，autolayout 会自动根据 cell 中的内容计算出对应的高度/宽度。</p>

<h3>TableView 中的 cell 自适应</h3>

<p>要让 table view 的 cell 自适应内容，有几个要点：</p>

<ul>
<li>设置的 AutoLayout 约束必须让 cell 的 contentView 知道如何自动延展。关键点是 contentView 的 4 个边都要设置连接到内容的约束，并且内容是会动态改变尺寸的。</li>
<li>UITableView 的 <code>rowHeight</code> 的值要设置为 <code>UITableViewAutomaticDimension</code></li>
<li>和 iOS 7 一样，可以实现 <code>estimatedHeightForRowAtIndexPath</code> 方法提升 table view 的第一次加载速度。</li>
<li>任何时候 cell 的 <code>intrinsicContentSize</code> 改变了（比如 table view 的宽度变了），都必须重新加载 table view 以更新 cell。</li>
</ul>


<h4>例子</h4>

<p>在 Xcode 中新建一个项目，在 storyboard 中创建一个 UITableViewController 的 IB，创建一个如下样子的 cell：</p>

<p><img src="http://vit0.com/images/posts/2014-11-13-self-size-cell-1.jpg" alt="图1 cell 外观" /></p>

<p><em>图1 cell 外观</em></p>

<p>这个 cell 中有 3 个元素，其中 imageView 的 autoLayout 约束为：</p>

<ul>
<li>imageView 左边离 contentView 左边 0</li>
<li>imageView 上边离 contentView 上边 0</li>
<li>imageView 的 width 和 height 为 80</li>
<li>imageView 下边离 contentView 下边大于等于 0（为了防止内容太少，导致 cell 高度小于图片高度）</li>
</ul>


<p>titleLabel 的 autoLayout 约束为：</p>

<ul>
<li>titleLabel 左边离 imageView 右边 8</li>
<li>titleLabel 上边和 imageView 上边在同一只线上</li>
<li>titleLabel 右边离 contentView 右边 0</li>
<li>titleLabel 下边离 description 上边 8</li>
<li>titleLabel 的高度小于等于 22，优先级为 250</li>
</ul>


<p>descriptionLabel 的约束为：</p>

<ul>
<li>descriptionLabel 左边和 titleLabel 左边在同一直线上</li>
<li>descriptionLabel 上边里 titleLabel 8</li>
<li>descriptionLabel 下边里 contentView 下边 0</li>
<li>descriptionLabel 右边离 contentView 右边 0</li>
</ul>


<p>然后在这个 IB 对应的  UITableViewController 中加载一些数据进去，显示效果如图：</p>

<p><img src="http://vit0.com/images/posts/2014-11-13-self-size-cell-2.jpg" alt="图2 自适应 cell 效果图" /></p>

<p><em>图2 自适应 cell 效果图</em></p>

<p>实现这个效果，我除了设置了 autoLayout，还设置了 tableView 的 <code>rowHeight = UITableViewAutomaticDimension</code>，然后就是这样了。一点计算 cell 高度的代码都没有！！我连 <code>heightForRowAtIndexPath</code>都不用实现，真的是&hellip;.爽出味啊！所以如果已经在开发 iOS 8 Only 的应用了一定要用autolayout，把烦人的计算交给 autolayout 去吧。</p>

<h3>CollectionView 中的 cell 自适应</h3>

<p>在 collection view 中也能让 cell 自适应内容大小，如果 UICollectionView 的 layout 是一个 UICollectionViewFlowLayout，只需要将 <code>layout.itemSize = ...</code> 改成 <code>layout.estimatedItemSize = ...</code>。
只要设置了 layout 的 estimatedItemSize，collection view 就会根据 cell 里面的 autolayout 约束去确定cell 的大小。</p>

<p><strong>原理：</strong></p>

<ol>
<li>collection view 根据 layout 的 estimatedItemSize 算出估计的 contentSize，有了 contentSize collection view 就开始显示</li>
<li>collection view 在显示的过程中，即将被显示的 cell 根据 autolayout 的约束算出自适应内容的 size</li>
<li>layout 从 collection view 里获取更新过的 size attribute</li>
<li>layout 返回最终的 size attribute 给 collection view</li>
<li>collection 使用这个最终的 size attribute 展示 cell</li>
</ol>


<h2>总结</h2>

<p>这次 iOS 8 的发布对 UI 开发来说是越来方便了，很多以前需要写大量计算的代码现在都可以通过拖拖 IB 上的 UI 控件就可以实现了，当然首先你要会 autolayout。 如果很幸运的在开发 iOS 8 only 的应用，真的可以删除<code>heightForRowAtIndexPath</code>中那些繁重的计算代码了！让 autolayout 帮我们完成所有的工作吧。</p>

<h2>参考</h2>

<ul>
<li><a href="https://developer.apple.com/videos/wwdc/2014/#226-video">WWDC Session 226 Whats New in Table and Collection Views</a></li>
<li><a href="http://captechconsulting.com/blog/tyler-tillage/ios-8-tutorial-series-auto-sizing-table-cells">iOS 8 Tutorial Series: Auto Sizing Table Cells</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 8 Extension Today Widget 开发总结：数据共享]]></title>
    <link href="http://vit0.com/blog/2014/11/12/ios-8-extension-today-widget-kai-fa-zong-jie/"/>
    <updated>2014-11-12T21:34:00+08:00</updated>
    <id>http://vit0.com/blog/2014/11/12/ios-8-extension-today-widget-kai-fa-zong-jie</id>
    <content type="html"><![CDATA[<p>这篇文章主要记录了在制作 Today Widget 时的一些思考，如果想要知道如何创建一个 Today Widget，可以参考下面的文章：</p>

<ul>
<li><a href="http://www.raywenderlich.com/83809/ios-8-today-extension-tutorial">绿皮网的 iOS 8 Today Extension tutorial(英文)</a></li>
<li><a href="http://onevcat.com/2014/08/notification-today-widget/">猫神的WWDC 2014 Session笔记 - iOS 通知中心扩展制作入门</a></li>
</ul>


<hr />

<p>在制作 Extension 的过程中还是遇到了一些坑，这里做一些记录。</p>

<p>Extension 的本质：相当于是一个独立的小 App，它可以做到通过 group 的方式和主 app 共享数据。</p>

<p>对于 Today widget 的开发实际上还是比较简单，可以当做是制作一个独立的页面，拉拉 outlet、action 之类的，然后响应数据更新界面，响应动作执行跳转等等。但是这里最大的疑问是数据共享的问题。</p>

<p>从文档中可以知道，想要让主 app 和 extension 之间共享数据，需要通过一个共享文件目录进行共享。这个共享目录通过指定一个 group id 来获取。</p>

<h3>NSUserDefaults 共享数据</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="n">userDefaults</span> <span class="o">=</span> <span class="bp">NSUserDefaults</span><span class="p">(</span><span class="nl">suiteName</span><span class="p">:</span> <span class="s">&quot;group.extension.vito&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">userDefaults</span><span class="o">?</span><span class="p">.</span><span class="n">setObject</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="nl">forKey</span><span class="p">:</span> <span class="s">&quot;title&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>共享目录</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">let</span> <span class="n">fileManager</span> <span class="o">=</span> <span class="bp">NSFileManager</span><span class="p">.</span><span class="n">defaultManager</span><span class="p">()</span>
</span><span class='line'><span class="n">let</span> <span class="n">containerURL</span> <span class="o">=</span> <span class="n">fileManager</span><span class="p">.</span><span class="n">containerURLForSecurityApplicationGroupIdentifier</span><span class="p">(</span><span class="s">&quot;group.mycontainer&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">let</span> <span class="n">storeURL</span> <span class="o">=</span> <span class="n">containerURL</span><span class="o">?</span><span class="p">.</span><span class="n">URLByAppendingPathComponent</span><span class="p">(</span><span class="s">&quot;db.sqlite&quot;</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在知道了如何在共享区域保存数据，但是什么时机来保存数据呢？
一种方式是将应用的数据和 extension 的数据放到共享容器中，这样主应用和 extension 都可以访问到全部的数据。这样的好处就是可以保证 extension 和主应用中显示的数据可以是完全一致的，因为访问的数据就是同一份数据。但是貌似在现在的版本中<em>共享容器中的数据会在手机重装系统后丢失</em>，这似乎是一个 bug：</p>

<ul>
<li><a href="http://stackoverflow.com/questions/24641768/accessing-core-data-sql-database-in-ios-8-extension-sharing-data-between-app-an">StackOverflow 上的讨论</a></li>
<li><a href="http://openradar.appspot.com/18750178">Open 状态的相关 Bug report rdar://18750178</a></li>
</ul>


<h3>Background Fetch 机制联想到 extension 的共享数据刷新</h3>

<p>Today widget 也是有 Background fetch 机制的，在<code>func widgetPerformUpdateWithCompletionHandler(completionHandler: ((NCUpdateResult) -&gt; Void)!)</code>方法中就是接收到后台刷新的方法。设备会在认为合适的时间调用这里的代码。</p>

<p>有了后台刷新机制，我们可以就可以很方便的刷新共享区域的数据，比如在主应用中的 background fetch 代码中执行写入数据的代码，设置 background fetch 的时间间隔为一天。这样可以让 extension 每一天显示的数据都是新的。这种方式可以说是比较简单省事，又能达到预期效果的实现方式。
缺点是：由于backgroud fetch 的刷新时机实际上不是很准确的，就有可能会有一些小的延迟等情况，而且用户也可以在系统的设置应用中关闭其它应用的 background fetch 功能。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 8 HealthKit 介绍]]></title>
    <link href="http://vit0.com/blog/2014/10/30/ios-8-healthkit-jie-shao/"/>
    <updated>2014-10-30T22:34:00+08:00</updated>
    <id>http://vit0.com/blog/2014/10/30/ios-8-healthkit-jie-shao</id>
    <content type="html"><![CDATA[<h2>如何创建 HealthKit 数据</h2>

<p>在创建数据前，我们首先需要知道 HealthKit 的数据结构。</p>

<p><strong>HKUnit</strong></p>

<p>是基本的数据单位，它下面有很多子类表示不同的单位。</p>

<p><strong>HKQuantity</strong></p>

<p>表示某一种数据单位的数量，可以通过这个对象获取一种单位转换成另一种单位的值：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">HKUnit</span> <span class="o">*</span><span class="n">gramUnit</span> <span class="o">=</span> <span class="p">[</span><span class="n">HKUnit</span> <span class="n">gramUnit</span><span class="p">];</span>
</span><span class='line'><span class="n">HKQuantity</span> <span class="o">*</span><span class="n">grams</span> <span class="o">=</span> <span class="p">[</span><span class="n">HKQuantity</span> <span class="nl">quantityWithUnit</span><span class="p">:</span><span class="n">gramUnit</span> <span class="nl">doubleValue</span><span class="p">:</span><span class="mi">20</span><span class="p">];</span>
</span><span class='line'><span class="kt">double</span> <span class="n">kg</span> <span class="o">=</span> <span class="p">[</span><span class="n">grams</span> <span class="nl">doubleValueForUnit</span><span class="p">:[</span><span class="n">HKUnit</span> <span class="nl">unitFromString</span><span class="p">:</span><span class="s">@&quot;kg&quot;</span><span class="p">]];</span>
</span><span class='line'><span class="c1">// kg -&gt; 0.2</span>
</span></code></pre></td></tr></table></div></figure>


<p>但是前提是这两个互相转换的单位之间是理论上可以转换的，可以通过 HKUnit 的实例方法 <code>- (BOOL)isCompatibleWithUnit: (HKUnit *)unit;</code> 来判断两个单位之间是否可以转换</p>

<p><strong>HKObjectType</strong></p>

<p>用来表示一个数据是什么类型的，HealthKit 中有几十种类型。HKObjectType 的层级结构可以看下图：</p>

<p><img src="http://vit0.com/images/posts/2014-07-18-ios-7-yu-yin-he-cheng-qi-avspeechsynthesizer-1.png" alt="图1 HKObjectType 的层级结构" /></p>

<p><em>图1 HKObjectType 的层级结构</em></p>

<p>在 HealthKit 中我们不能创建自己的类型，但是理解了 HKObjectType 的数据结构对我们今后的开发有很大好处的。
HKObjectType 对象中主要有两个属性：</p>

<ul>
<li>identifier</li>
<li>type name</li>
</ul>


<p>我们可以根据需要创建不同类型的 HKObjectType：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'> <span class="k">@interface</span> <span class="nc">HKobjectType</span> : <span class="bp">NSObject</span>
</span><span class='line'>  <span class="o">+</span> <span class="p">(</span><span class="n">HKQuantityType</span> <span class="o">*</span><span class="p">)</span><span class="nl">quantityTypeForIdentifier</span><span class="p">:(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">identifier</span><span class="p">;</span>
</span><span class='line'>  <span class="o">+</span> <span class="p">(</span><span class="n">HKCategoryType</span> <span class="o">*</span><span class="p">)</span><span class="nl">categoryTypeForIdentifier</span><span class="p">:(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">identifier</span><span class="p">;</span>
</span><span class='line'>  <span class="o">+</span> <span class="p">(</span><span class="n">HKCharacteristicType</span> <span class="o">*</span><span class="p">)</span><span class="nl">characteristicTypeForIdentifier</span><span class="p">:(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">identifier</span><span class="p">;</span>
</span><span class='line'> <span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>HKObject</strong></p>

<p>所有存储在 HealthKit 中的数据都是 HKObject 的子类。HKObject 的类结构和 HKObjectType 的类结构很相似</p>

<p><img src="http://vit0.com/images/posts/2014-07-18-ios-7-yu-yin-he-cheng-qi-avspeechsynthesizer-2.png" alt="图2 HKObject 类的层级结构" /></p>

<p><em>图2 HKObject 类的层级结构</em></p>

<p><strong>HKQuantitySample</strong></p>

<p>是目前 HealthKit 中使用最广泛的一个 HKObject。它主要有两个属性：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'> <span class="k">@interface</span> <span class="nc">HKQuantitySample</span>
</span><span class='line'>  <span class="k">@property</span> <span class="p">(</span><span class="k">readonly</span><span class="p">)</span> <span class="n">HKQuantityType</span> <span class="o">*</span><span class="n">quantityType</span><span class="p">;</span>  <span class="c1">// 表示这个数量是什么类型的</span>
</span><span class='line'>  <span class="k">@property</span> <span class="p">(</span><span class="k">readonly</span><span class="p">)</span> <span class="n">HKQuantity</span> <span class="o">*</span><span class="n">quantity</span><span class="p">;</span> <span class="c1">// 数量的值</span>
</span><span class='line'> <span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>需要注意的是，<code>quantityType</code> 和 <code>quantity</code> 必须是正确匹配的否则在运行时程序会抛出异常。</p>

<p><strong>HKCategorySample</strong></p>

<p>它和 HKQuantitySample 类似</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="nc">HKCategorySample</span>
</span><span class='line'>    <span class="k">@property</span> <span class="p">(</span><span class="k">readonly</span><span class="p">)</span> <span class="n">HKCategoryType</span> <span class="o">*</span><span class="n">categoryType</span><span class="p">;</span>
</span><span class='line'>    <span class="k">@property</span> <span class="p">(</span><span class="k">readonly</span><span class="p">)</span> <span class="bp">NSInteger</span> <span class="n">value</span><span class="p">;</span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>HKSample</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="nc">HKSample</span>
</span><span class='line'>    <span class="k">@property</span> <span class="p">(</span><span class="k">readonly</span><span class="p">)</span> <span class="n">HKSampleType</span> <span class="o">*</span><span class="n">sampleType</span><span class="p">;</span> <span class="c1">// 会依据子类来确定这个类型的最终值</span>
</span><span class='line'>    <span class="k">@property</span> <span class="p">(</span><span class="k">readonly</span><span class="p">)</span> <span class="bp">NSDate</span> <span class="o">*</span><span class="n">startDate</span><span class="p">;</span>
</span><span class='line'>    <span class="k">@property</span> <span class="p">(</span><span class="k">readonly</span><span class="p">)</span> <span class="bp">NSDate</span> <span class="o">*</span><span class="n">endDate</span><span class="p">;</span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>HKObject</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="nc">HKObject</span>
</span><span class='line'>    <span class="k">@property</span> <span class="p">(</span><span class="k">readonly</span><span class="p">)</span> <span class="bp">NSUUID</span> <span class="o">*</span><span class="n">UUID</span><span class="p">;</span> <span class="c1">// 唯一识别</span>
</span><span class='line'>    <span class="k">@property</span> <span class="p">(</span><span class="k">readonly</span><span class="p">)</span> <span class="n">HKSource</span> <span class="o">*</span><span class="n">source</span><span class="p">;</span> <span class="c1">// 数据来源</span>
</span><span class='line'>    <span class="k">@property</span> <span class="p">(</span><span class="k">readonly</span><span class="p">)</span> <span class="bp">NSDictionary</span> <span class="o">*</span><span class="n">metadata</span><span class="p">;</span> <span class="c1">// 其它数据</span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>HKObject 中的所有属性都是不可变的，因为一旦数据收集后就不应该被更改。HKObject 也是不可变的。所以想要创建一个 HKObject 数据我们应该通过 HKQuantitySample 来创建</p>

<h3>创建一个 HKObject</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="bp">NSString</span> <span class="o">*</span><span class="n">identifier</span> <span class="o">=</span> <span class="n">HKQuantityTypeIdentifierBodyTemperature</span><span class="p">;</span>
</span><span class='line'><span class="n">HKQuantityType</span> <span class="o">*</span><span class="n">tempType</span> <span class="o">=</span> <span class="p">[</span><span class="n">HKObjectType</span> <span class="nl">quantityTypeForIdentifier</span><span class="p">:</span><span class="n">identifier</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="n">HKQuantity</span> <span class="o">*</span><span class="n">myTemp</span> <span class="o">=</span> <span class="p">[</span><span class="n">HKQuantity</span> <span class="nl">quantityWithUnit</span><span class="p">:[</span><span class="n">HKUnit</span> <span class="n">degreeFahrenheitUnit</span><span class="p">]</span> <span class="nl">doubleValue</span><span class="p">:</span><span class="mf">98.6</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="bp">NSDictionary</span> <span class="o">*</span><span class="n">meta</span> <span class="o">=</span> <span class="l">@{</span>
</span><span class='line'>    <span class="nl">HKMetadataKeyBodyTemperatureSensorLocation</span><span class="p">:</span> <span class="l">@(</span><span class="n">HKBodyTemperatureSensorLocationEar</span><span class="l">)</span>
</span><span class='line'><span class="l">}</span>
</span><span class='line'><span class="n">HKQuantitySample</span> <span class="o">*</span><span class="n">temperatureSample</span> <span class="o">=</span> <span class="p">[</span><span class="n">HKQuantitySample</span> <span class="nl">quantitySampleWithType</span><span class="p">:</span><span class="n">tempType</span>
</span><span class='line'>                    <span class="nl">quantity</span><span class="p">:</span><span class="n">myTemp</span>
</span><span class='line'>                    <span class="nl">startDate</span><span class="p">:[</span><span class="bp">NSDate</span> <span class="n">date</span><span class="p">]</span>
</span><span class='line'>                    <span class="nl">endDate</span><span class="p">:</span> <span class="p">[</span><span class="bp">NSDate</span> <span class="n">date</span><span class="p">]</span>
</span><span class='line'>                    <span class="nl">metadata</span><span class="p">:</span> <span class="n">meta</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过上面的代码，我们已经创建了一个新的数据，接下来我们要将这个数据保存到 HealthKit 的数据库中</p>

<h2>保存 HealthKit 数据</h2>

<p><strong>HKHealthStore</strong></p>

<p>可以想象成我们通过这个对象与 HealthKit 的数据库进行连接，可以通过这个对象保存和查询数据。需要注意的是，HKHealthStore 在应用中应该只保存一个对象，因为每次创建新的对象，实际上相当于是同一个对象，可以理解为它们都会链接到同一个数据库。</p>

<p>使用 HKHealthStore 保存数据的例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="nb">self</span><span class="p">.</span><span class="n">store</span> <span class="o">=</span> <span class="p">[</span><span class="n">HKHealthStore</span> <span class="n">new</span><span class="p">];</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="n">HKQuantitySample</span> <span class="o">*</span><span class="n">mySample</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="n">newSample</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">store</span> <span class="nl">saveObject</span><span class="p">:</span><span class="n">mySample</span> <span class="nl">withCompletion</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="kt">BOOL</span> <span class="n">success</span><span class="p">,</span> <span class="bp">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">success</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Object Saved!&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<p>保存数据的代码看起来很容易理解，成功保存数据后，接下来我们希望能从 HealthKit 中获取我们想要的数据</p>

<h2>获取 HealthKit 数据</h2>

<p>可以获取的数据除了 HKObject 外还有 Characteristics</p>

<p><strong>Characteristics</strong></p>

<p>这个数据是用户保存在 HealthKit 中个人信息，这些信息一般情况下不会改变。比如：生日日期、血型、性别等
通过 API 获取这些信息很简单，下面代码用来获取用户记录在 healthKit 中的生日</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="bp">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">;</span>
</span><span class='line'><span class="bp">NSDate</span> <span class="o">*</span><span class="n">dateOfBirth</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">store</span> <span class="nl">dateOfBirthWithError</span><span class="p">:</span><span class="o">&amp;</span><span class="n">error</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>但是大部分数据并不能用这么简单的方式获取，这时候我们就需要通过像条件查询一样的东西来查询数据</p>

<p><strong>HKQuery</strong></p>

<p>我们可以使用 Predicates</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">HKQuantity</span> <span class="o">*</span><span class="n">weight</span> <span class="o">=</span> <span class="p">...</span>
</span><span class='line'><span class="p">[</span><span class="bp">NSPredicate</span> <span class="nl">predicateWithFormat</span><span class="p">:</span><span class="s">@&quot;%k &gt; %@&quot;</span><span class="p">,</span> <span class="n">HKPredicateKeyPathQuantity</span><span class="p">,</span> <span class="n">weight</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>为了简化 NSPredicate 的使用，HealthKit 中提供了 <code>NSPredicateOperatorType</code>，我们可以将这个 Enum 传入 HKQuery 的一个工厂方法中，生成想要的 HKQuery 对象。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSPredicateOperatorType</span> <span class="n">greaterThan</span> <span class="o">=</span> <span class="n">NSGreaterThanPredicateOperatorType</span><span class="p">;</span>
</span><span class='line'><span class="p">[</span><span class="n">HKQuery</span> <span class="nl">predicateForQuantitySamplesWithOperatorType</span><span class="p">:</span><span class="n">greaterThan</span> <span class="nl">quantity</span><span class="p">:</span><span class="n">weight</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>HKSampleQuery</strong></p>

<ul>
<li>可以设置限制: HKObjectQueryNoLimit</li>
<li>排序：NSSortDescriptors</li>
</ul>


<p>一个获取最近血糖值的例子</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">HKQuantityType</span> <span class="o">*</span><span class="n">bloodSugar</span> <span class="o">=</span> <span class="p">...</span>
</span><span class='line'><span class="bp">NSString</span> <span class="o">*</span><span class="n">endKey</span> <span class="o">=</span> <span class="n">HKSampleSortIdentifierEndDate</span><span class="p">;</span>
</span><span class='line'><span class="bp">NSSortDescriptor</span> <span class="o">*</span><span class="n">endDate</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSSortDescriptor</span> <span class="nl">sortDescriptorWithKey</span><span class="p">:</span><span class="n">endKey</span> <span class="nl">ascending</span><span class="p">:</span><span class="nb">NO</span><span class="p">];</span>
</span><span class='line'><span class="n">HKSampleQuery</span> <span class="o">*</span><span class="n">query</span> <span class="o">=</span> <span class="p">[[</span><span class="n">HKSampleQuery</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithSampleType</span><span class="p">:</span><span class="n">bloodSugar</span>
</span><span class='line'>                <span class="nl">predicate</span><span class="p">:</span><span class="nb">nil</span>
</span><span class='line'>                <span class="nl">limit</span><span class="p">:</span><span class="mi">1</span>
</span><span class='line'>                <span class="nl">sortDescriptors</span><span class="p">:</span><span class="l">@[</span><span class="n">endDate</span><span class="l">]</span>
</span><span class='line'>                <span class="nl">resultsHandler</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">HKSampleQuery</span> <span class="o">*</span><span class="n">query</span><span class="p">,</span> <span class="bp">NSArray</span> <span class="o">*</span><span class="n">results</span><span class="p">,</span> <span class="bp">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">HKQuantitySample</span> <span class="o">*</span><span class="n">sample</span> <span class="o">=</span> <span class="p">[</span><span class="n">results</span> <span class="n">lastObject</span><span class="p">];</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Sample:  %@&quot;</span><span class="p">,</span> <span class="n">sample</span><span class="p">);</span>
</span><span class='line'><span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过上面的代码可以获取到指定的信息，但是如果我们想要实时更新数据，在每次数据改变时都会获取到最新的数据，我们可以使用 <code>HKObserverQuery</code></p>

<p><strong>HKObserverQuery</strong></p>

<p>用于监听 HealthKit 数据库中的改变。
它和 HKSampleQuery 的不同之处在于，它是一直处于运行状态的，绑定在这个 Query 中的回调代码会在每次数据改变时被调用。
并且 HKObserverQuery 还支持 background delivery</p>

<p>示例代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">HKQuantityType</span> <span class="o">*</span><span class="n">bloodSugar</span> <span class="o">=</span> <span class="p">...</span>
</span><span class='line'><span class="n">HKObserverQuery</span> <span class="o">*</span><span class="n">query</span><span class="p">;</span>
</span><span class='line'><span class="n">query</span> <span class="o">=</span> <span class="p">[[</span><span class="n">HKObserverQuery</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithSampleType</span><span class="p">:</span><span class="n">bloodSugar</span>
</span><span class='line'>            <span class="nl">predicate</span><span class="p">:</span><span class="nb">nil</span>
</span><span class='line'>            <span class="nl">updateHandler</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">HKObserverQuery</span> <span class="o">*</span><span class="n">query</span><span class="p">,</span> <span class="n">HKObserverQueryCompletionHandler</span> <span class="n">handler</span><span class="p">,</span> <span class="bp">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Updated!&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}]</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>HKAnchoredObjectQuery</strong></p>

<p>作为 HealthKit 的数据提供方，用户每次添加了新数据后，等到一个何时的时机，需要向 HealthKit 的云端数据库中同步数据。开发者可能会想到获取所有的数据，再判断哪些数据需要上传。而 HKAnchoredObjectQuery</p>

<p>HKAnchoredObjectQuery 可以设置限制数，还可以设置一个锚（Anchors）。等一下&hellip;锚是什么东西啊喂&hellip;.</p>

<p>我们来看这两张图：</p>

<p>1.这是 anchor=0 时我们会获取所有的数据</p>

<p><img src="http://vit0.com/images/posts/2014-07-18-ios-7-yu-yin-he-cheng-qi-avspeechsynthesizer-3.png" alt="" /></p>

<p>2.当 anchor=3 时我们会获取从第四个数据开始之后的所有数据</p>

<p><img src="http://vit0.com/images/posts/2014-07-18-ios-7-yu-yin-he-cheng-qi-avspeechsynthesizer-4.png" alt="" /></p>

<p>这其实就是个索引一样的东西&hellip;anchor 应该设置为我们最后一次见到的数据的 anchor 值，如果还没有见到过任何数据，可以将 anchor 设置为0，在获取数据的 callback 中我们会得到新的 anchor。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="nb">self</span><span class="p">.</span><span class="n">lastAnchor</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="n">HKQuantityType</span> <span class="o">*</span><span class="n">bloodSugar</span> <span class="o">=</span> <span class="p">...</span>
</span><span class='line'><span class="n">HKAnchoredObjectQuery</span> <span class="o">*</span><span class="n">query</span><span class="p">;</span>
</span><span class='line'><span class="n">query</span> <span class="o">=</span> <span class="p">[[</span><span class="n">HKAnchoredObjectQuery</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithType</span><span class="p">:</span><span class="n">bloodSugar</span>
</span><span class='line'>                <span class="nl">predicate</span><span class="p">:</span><span class="nb">nil</span>
</span><span class='line'>                <span class="nl">anchor</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">lastAnchor</span>
</span><span class='line'>                <span class="nl">limit</span><span class="p">:</span><span class="n">HKObjectQueryNoLimit</span>
</span><span class='line'>                <span class="nl">completionHandler</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">HKAnchoredObjectQuery</span> <span class="o">*</span><span class="n">query</span><span class="p">,</span> <span class="bp">NSArray</span> <span class="o">*</span><span class="n">results</span><span class="p">,</span> <span class="bp">NSUInteger</span> <span class="n">newAnchor</span><span class="p">,</span> <span class="bp">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">lastAnchor</span> <span class="o">=</span> <span class="n">newAnchor</span><span class="p">;</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Results: %@&quot;</span><span class="p">,</span> <span class="n">results</span><span class="p">);</span>
</span><span class='line'><span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<h3>执行 Query</h3>

<p>执行 queries 的方法在 <code>HKHealthStore</code> 中。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="nc">HKHealthStore</span> :<span class="bp">NSObject</span>
</span><span class='line'>    <span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">executeQuery</span><span class="p">:(</span><span class="n">HKQuery</span> <span class="o">*</span><span class="p">)</span><span class="n">query</span><span class="p">;</span>
</span><span class='line'>    <span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">stopQuery</span><span class="p">:(</span><span class="n">HKQuery</span> <span class="o">*</span><span class="p">)</span><span class="n">query</span><span class="p">;</span> <span class="c1">// 调用这个方法会停止查询数据，并且阻止 query 中的回调被执行</span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>一般只有长时间运行的 queries 需要被停止。</p>

<h3>获取统计数据</h3>

<p>我们可以获取所有的数据，然后手动计算出我们想要的统计数据。但是我们也可以使用系统提供的 <code>HKStatistics</code>对象获取统计数据。</p>

<p><strong>HKStatistics</strong></p>

<ul>
<li>可以获取几种统计数据：Sum、Min、Max、Average</li>
<li>获取指定数据源的所有数据</li>
<li>HKStatistics 只支持获取 quantity 类型的数据</li>
</ul>


<p><strong>Classifying Types</strong></p>

<p>不是所有的类型都一样的，比如能量消耗值，我们会关心的是最小值、最大值和平均值，所有能量消耗的总和的意义看起来没有其它几个值重要。</p>

<ul>
<li>Discrete 类型只关心：最小值、最大值和平均值</li>
<li>Cumulative 类型只关心：总和</li>
</ul>


<p>HKQuantityType 总是 discrete 或者 cumulative，它有一个 <code>aggregationStyle</code>的属性，可以通过这个属性来判断一个 HKQuantityType 是什么类型的。</p>

<p>回到<code>HKStatistics</code>，我们可以指定一个 <code>HKStatisticsOptions</code> 告诉 HKStatistics 我们需要什么样的统计数据</p>

<p><strong>HKStatisticsQuery</strong></p>

<p>如何使用HKStatisticsQuery 获取今天走的步数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">HKQuantityType</span> <span class="o">*</span><span class="n">stepCount</span> <span class="o">=</span> <span class="p">...</span>
</span><span class='line'><span class="bp">NSPredicate</span> <span class="o">*</span><span class="n">today</span> <span class="o">=</span> <span class="p">...</span>
</span><span class='line'><span class="n">HKStatisticsOptions</span> <span class="n">sumOptions</span> <span class="o">=</span> <span class="n">HKStatisticsOptionCumulativeSum</span><span class="p">;</span>
</span><span class='line'><span class="n">HKStatisticsQuery</span> <span class="o">*</span><span class="n">query</span><span class="p">;</span>
</span><span class='line'><span class="n">query</span> <span class="o">=</span> <span class="p">[[</span><span class="n">HKStatisticsQuery</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithQuantityType</span><span class="p">:</span><span class="n">stepCount</span>
</span><span class='line'>                <span class="nl">quantitySamplePredicate</span><span class="p">:</span><span class="n">today</span>
</span><span class='line'>                <span class="nl">options</span><span class="p">:</span><span class="n">sumOptions</span>
</span><span class='line'>                <span class="nl">completionHandler</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">HKStatisticsQuery</span> <span class="o">*</span><span class="n">query</span><span class="p">,</span> <span class="n">HKStatistic</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="bp">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">HKQuantity</span> <span class="o">*</span><span class="n">sum</span> <span class="o">=</span> <span class="p">[</span><span class="n">result</span> <span class="n">sumQuantity</span><span class="p">];</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Steps: %lf&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">sum</span> <span class="nl">doubleValueForUnit</span><span class="p">:[</span><span class="n">HKUnit</span> <span class="n">countUnit</span><span class="p">]]);</span>
</span><span class='line'><span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>HKStatisticsCollection</strong></p>

<p>如果我们想要获取多个统计数据，我们可以使用<code>HKStatisticsCollection</code>, 我们可以指定一个时间段做为统计数据的间距，比如 24 小时为一个统计单元，<code>HKStatisticsCollection</code> 中的数据就会是每个 24 小时内的统计统计数据的集合。</p>

<p><img src="http://vit0.com/images/posts/2014-07-18-ios-7-yu-yin-he-cheng-qi-avspeechsynthesizer-5.png" alt="图3 HKStatisticsCollection 中的数据示意图" /></p>

<p><em>图3 HKStatisticsCollection 中的数据示意图</em></p>

<p><strong>HKStatisticsCollectionQuery</strong></p>

<p>如何使用：</p>

<ul>
<li>设置一个 Statistics options</li>
<li>设置 Anchor date</li>
<li>Interval componets</li>
<li>获取 Collection</li>
</ul>


<p>代码类似其它 Query 的代码，就不写了。</p>

<h2>HealthKit 最佳实战</h2>

<p>开始使用 HealthKit 首先需要在项目中开启 HealthKit 功能。方法是<strong>项目 target -> Capabilities  -> 开启 Health Kit 功能</strong></p>

<p><strong>关于隐私和权限</strong></p>

<ul>
<li>HealthKit 中的数据对用户来说可能是非常敏感的数据</li>
<li>不同类型数据的权限是分开的</li>
<li>读/写权限是分开的</li>
</ul>


<p>在使用 HealthStore 之前开发者需要先使用下面的方法请求权限。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">requestAuthorizationToShareTypes:</span><span class="p">(</span><span class="bp">NSSet</span> <span class="o">*</span><span class="p">)</span><span class="nv">typesToShare</span>
</span><span class='line'>                <span class="nf">readTypes:</span><span class="p">(</span><span class="bp">NSSet</span> <span class="o">*</span><span class="p">)</span><span class="nv">typesToRead</span>
</span><span class='line'>                <span class="nf">completion:</span><span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="kt">BOOL</span> <span class="n">success</span><span class="p">,</span> <span class="bp">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">))</span><span class="nv">completion</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中，typesToshare 用于指定<strong>读权限</strong>的类型，typesToRead 指定写权限的类型。一旦程序中请求了权限，系统会弹出一个设置权限的界面，如下图：</p>

<p><img src="http://vit0.com/images/posts/2014-07-18-ios-7-yu-yin-he-cheng-qi-avspeechsynthesizer-6.png" alt="图4 请求 HealthKit 多个类型权限的弹出界面" /></p>

<p><em>图4 请求 HealthKit 多个类型权限的弹出界面</em></p>

<p>请求完权限后，在程序中，可以通过 <code>- (HKAuthorizationStatus)authorizationStatusForType:(HKObjectType *)type;</code>查看是否获得了指定类型的权限。</p>

<h2>总结</h2>

<p>对于开发者来说 HealthKit 给应用带来更多的可能性，开发者可以通过获取 HealthKit 内的信息让自己的 App 内容更佳充实。</p>

<h2>引用</h2>

<p>这篇文章所有内容来自<a href="https://developer.apple.com/videos/wwdc/2014/#203-video">WWDC Session 203 Introducing Healthkit</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 7 语音合成器 - AVSpeechSynthesizer]]></title>
    <link href="http://vit0.com/blog/2014/07/18/ios-7-yu-yin-he-cheng-qi-avspeechsynthesizer/"/>
    <updated>2014-07-18T23:41:00+08:00</updated>
    <id>http://vit0.com/blog/2014/07/18/ios-7-yu-yin-he-cheng-qi-avspeechsynthesizer</id>
    <content type="html"><![CDATA[<p>再过不久格志就将迎来一次比较大的版本更新，现在主要功能都开发的差不多了，剩下一些细节的完善。这两天也是正在制作格志的新手引导功能，前段时间 facebook 出的 Paper 中的新手引导效果非常棒，这次格志的新手引导也有借鉴了部分，其中一个功能是使用语音朗读出新手引导的文字内容。</p>

<p>由于格志是一个时髦的应用（Only iOS 7）…所以可以很开心的使用 iOS 7 中才有的 AVSpeechSynthesizer，做了一搜索后，可以说这货真的很简单、很好用！</p>

<h2>如何使用</h2>

<p>首先，使用 AVSpeechSynthesizer 时需要 <code>#import &lt;AVFoundation/AVFoundation.h&gt;</code></p>

<p>然后我们可以用几行代码实现让程序阅读一段文字：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="bp">NSString</span> <span class="o">*</span><span class="n">string</span> <span class="o">=</span> <span class="s">@&quot;Hello, World!&quot;</span><span class="p">;</span>
</span><span class='line'><span class="bp">AVSpeechUtterance</span> <span class="o">*</span><span class="n">utterance</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">AVSpeechUtterance</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithString</span><span class="p">:</span><span class="n">string</span><span class="p">];</span>
</span><span class='line'><span class="n">utterance</span><span class="p">.</span><span class="n">voice</span> <span class="o">=</span> <span class="p">[</span><span class="bp">AVSpeechSynthesisVoice</span> <span class="nl">voiceWithLanguage</span><span class="p">:</span><span class="s">@&quot;en-US&quot;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="bp">AVSpeechSynthesizer</span> <span class="o">*</span><span class="n">speechSynthesizer</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">AVSpeechSynthesizer</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">speechSynthesizer</span> <span class="nl">speakUtterance</span><span class="p">:</span><span class="n">utterance</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>AVSpeechUtterance </code>对象用于封装要朗读的话语，可以指定这段话的语言、音量和语速等。</p>

<p>但是上面的代码有个问题，上面代码第三行中传入<code>AVSpeechUtterance</code>的<code>AVSpeechSynthesisVoice </code>对象是在英文的语言环境下阅读文字，如果<strong><em>文字内容的语言</em></strong>和<strong><em>声音的语言</em></strong>不同，程序就不会发出声音。而格志是个国际化 App，目前支持7种语言，所以要针对不同的语言内容设置正确的语音语言代码（如：en-US, zh-CH）。</p>

<p>可以通过<code>[AVSpeechSynthesisVoice speechVoices]</code>查询所有支持的语言，幸运的是可以通过<code>[AVSpeechSynthesisVoice currentLanguageCode]</code>获取用户当前系统设置中的语言所对应的语言代码。所以上面的代码可以改成这样以支持国际化</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="bp">NSString</span> <span class="o">*</span><span class="n">string</span> <span class="o">=</span> <span class="s">@&quot;Hello, World!&quot;</span><span class="p">;</span>
</span><span class='line'><span class="bp">AVSpeechUtterance</span> <span class="o">*</span><span class="n">utterance</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">AVSpeechUtterance</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithString</span><span class="p">:</span><span class="n">string</span><span class="p">];</span>
</span><span class='line'><span class="bp">NSString</span> <span class="o">*</span><span class="n">code</span> <span class="o">=</span> <span class="p">[</span><span class="bp">AVSpeechSynthesisVoice</span> <span class="n">currentLanguageCode</span><span class="p">];</span> <span class="c1">// 获取用户当前的语言代码</span>
</span><span class='line'><span class="n">utterance</span><span class="p">.</span><span class="n">voice</span> <span class="o">=</span> <span class="p">[</span><span class="bp">AVSpeechSynthesisVoice</span> <span class="nl">voiceWithLanguage</span><span class="p">:</span><span class="n">code</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="bp">AVSpeechSynthesizer</span> <span class="o">*</span><span class="n">speechSynthesizer</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">AVSpeechSynthesizer</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">speechSynthesizer</span> <span class="nl">speakUtterance</span><span class="p">:</span><span class="n">utterance</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>到这里好像我所需要的功能就大概实现了，当然在真实环境中还应该对语速、音量等参数做一些微调，让语音听上去更自然清晰。</p>

<p>然后…<code>AVSpeechSynthesizer </code>不止只有这些，<code>AVSpeechSynthesizer </code>的方法中还有有暂停、停止和继续的方法，注意到停止和暂停方法都可以传入一个<code>(AVSpeechBoundary)boundary</code>的参数，用于决定程序是在一个单词朗读完（AVSpeechBoundaryWord）再暂停还是立即（AVSpeechBoundaryImmediate）暂停。</p>

<p><strong> AVSpeechSynthesizerDelegate</strong></p>

<p>在<code>AVSpeechSynthesizerDelegate</code>中其实其它方法都没什么好说的，都是些开始阅读、结束阅读、取消等的状态回调。但是有一个方法不同，它带了将要阅读的文字的 NSRange，这个方法是：<code>- (void)speechSynthesizer:(AVSpeechSynthesizer *)synthesizer willSpeakRangeOfSpeechString:(NSRange)characterRange utterance:(AVSpeechUtterance *)utterance;</code>，如果获取到将要阅读的文字是哪些，我们就可以做一些有趣的事情，如：像歌词字幕一样高亮正在阅读的文字，或者可以像下面一样在屏幕中只显示将要阅读的文字。</p>

<p><img src="http://vit0.com/images/posts/2014-07-18-ios-7-AVSpeechSynthesizer.gif" title="Speak delegate demo" alt="" /></p>

<h2>总结</h2>

<p>总之 <code>AVSpeechSynthesizer </code> 是一个简单又实用的语音合成类，分分钟上手有木有。使用语音朗读的场景感觉还是很多的，比如这次格志里用到的朗读用户引导的文字，语音导航，有声读物等等。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 7 UIKit Dynamic 学习总结]]></title>
    <link href="http://vit0.com/blog/2014/03/08/ios-7-uikit-dynamic-xue-xi-zong-jie/"/>
    <updated>2014-03-08T20:49:00+08:00</updated>
    <id>http://vit0.com/blog/2014/03/08/ios-7-uikit-dynamic-xue-xi-zong-jie</id>
    <content type="html"><![CDATA[<h2>什么是 UIKit Dynamics</h2>

<p>iOS 7 中推出的UIKit Dynamics，主要带来了模拟现实的二维动画效果，Apple 的高度封装让开发者不用知道太多物理知识也可以开发出逼真的物理动画。</p>

<ul>
<li>Real word inspired interactions</li>
<li>Combining predefined and interactive animations</li>
<li>Designed for UI</li>
</ul>


<h2>Why</h2>

<p>苹果鼓励模拟真实世界的交互而不只是简单的像素堆砌的拟物风格，所以苹果这些模拟现实的交互动画封装进了 UIKit，希望开发者能开发出更多模拟现实的交互。</p>

<h2>关键类</h2>

<ul>
<li><strong>UIDynamicAnimator</strong>，封装了底层 iOS 物理引擎，为动力项（UIDynamicItem）提供物理相关的功能和动画。</li>
<li><strong>UIDynamicBehavior</strong>，动力行为，为动力项提供不同的物理行为</li>
<li><strong>UIDynamicItem</strong>，动力项，相当于现实世界中的一个基本物体</li>
</ul>


<p><img src="http://vit0.com/images/posts/2014-03-08-uidynamic-1.png" alt="image" /></p>

<p>这三个类的结构是：UIDynamicAnimator 需要一个 refrence view 作为物理引擎的坐标系统，再根据不同需求添加各种动力行为（UIDynamicBehavior），而每个动力行为都可以指定一个或多个动力项（UIDynamicItem），常用的动力项就是一个普通的 View。</p>

<h2>UIDynamicAnimator</h2>

<p>UIDynamicAnimator 封装了底层 iOS 物理引擎，为动力项（UIDynamicItem）提供物理相关的功能和动画，并为这些动画提供上下文。Animator 作为底层 iOS 物理引擎和动力项（UIDynamicItem）之间的中介，通过 <code>- (void)addBehavior:(UIDynamicBehavior *)behavior;</code> 方法添加不同的动力行为，让动力项拥有物理功能和动画。</p>

<p>现在来看看 UIDynamicAnimator 都有哪些方法：</p>

<ul>
<li>初始化和管理一个 Dynamic Animator</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 传入一个 Reference view 创建一个 Dynamic Animator</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">initWithReferenceView:</span><span class="p">(</span><span class="bp">UIView</span><span class="o">*</span><span class="p">)</span><span class="nv">view</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 获取在 CGRect 内所有的动力项，这个 CGRect 是基于 Reference view 的二维坐标系统的</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">NSArray</span><span class="o">*</span><span class="p">)</span><span class="nf">itemsInRect:</span><span class="p">(</span><span class="bp">CGRect</span><span class="p">)</span><span class="nv">rect</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 添加动力行为</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addBehavior:</span><span class="p">(</span><span class="bp">UIDynamicBehavior</span> <span class="o">*</span><span class="p">)</span><span class="nv">behavior</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 删除指定的动力行为</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">removeBehavior:</span><span class="p">(</span><span class="bp">UIDynamicBehavior</span> <span class="o">*</span><span class="p">)</span><span class="nv">behavior</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 删除所有的动力行为</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">removeAllBehaviors</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>获取 Dynamic Animator’s 的状态</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 是否正在运行</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">readonly</span><span class="p">,</span> <span class="k">getter</span> <span class="o">=</span> <span class="n">isRunning</span><span class="p">)</span> <span class="kt">BOOL</span> <span class="n">running</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 获取所有的 Behaviors</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">readonly</span><span class="p">,</span> <span class="k">copy</span><span class="p">)</span> <span class="bp">NSArray</span><span class="o">*</span> <span class="n">behaviors</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">readonly</span><span class="p">)</span> <span class="bp">UIView</span><span class="o">*</span> <span class="n">referenceView</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 这个 delegate 中有两个回调方法，一个是在 animator 暂停的时候调用，一个是在将要恢复的时候调用</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">assign</span><span class="p">)</span> <span class="kt">id</span> <span class="o">&lt;</span><span class="bp">UIDynamicAnimatorDelegate</span><span class="o">&gt;</span> <span class="n">delegate</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 已经运行了多久的时间，是一个 NSTimeInterval</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="n">NSTimeInterval</span><span class="p">)</span><span class="nf">elapsedTime</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 如果动力项不是通过 animator 自动计算改变状态，比如，通过代码强制改变一个 item 的 transfrom 时，可以用这个方法通知 animator 这个 item 的改变。如果不用这个方法，animator 之后的动画会覆盖代码中对 item 做的改变，相当于代码改变 transform 变得没有意义。</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">updateItemUsingCurrentState:</span><span class="p">(</span><span class="kt">id</span> <span class="o">&lt;</span><span class="bp">UIDynamicItem</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">item</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Collection View Additions</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">initWithCollectionViewLayout:</span><span class="p">(</span><span class="bp">UICollectionViewLayout</span><span class="o">*</span><span class="p">)</span><span class="nv">layout</span> <span class="c1">// 传入一个 CollectionViewLayout 创建一个 Dynamic Animator</span>
</span><span class='line'><span class="err">–</span> <span class="nl">layoutAttributesForCellAtIndexPath</span><span class="p">:</span>
</span><span class='line'><span class="err">–</span> <span class="nl">layoutAttributesForDecorationViewOfKind</span><span class="p">:</span><span class="nl">atIndexPath</span><span class="p">:</span>
</span><span class='line'><span class="err">–</span> <span class="nl">layoutAttributesForSupplementaryViewOfKind</span><span class="p">:</span><span class="nl">atIndexPath</span><span class="p">:</span>
</span></code></pre></td></tr></table></div></figure>


<hr />

<p>从这里开始，让我们先创建一个项目，取名 DynamicDemo，选择 single view project。</p>

<p>在 ViewController.m 文件修改成如下代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="nc">ViewController</span> <span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">strong</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="bp">UIView</span> <span class="o">*</span><span class="n">squareView</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">strong</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="bp">UIDynamicAnimator</span> <span class="o">*</span><span class="n">animator</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">ViewController</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">super</span> <span class="n">viewDidLoad</span><span class="p">];</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">squareView</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UIView</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFrame</span><span class="p">:</span><span class="n">CGRectMake</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">)];</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">squareView</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIColor</span> <span class="n">orangeColor</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">view</span> <span class="nl">addSubview</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">squareView</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">animator</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UIDynamicAnimator</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithReferenceView</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">view</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码创建了一个方形 View，橘黄色背景色。还创建了一个UIDynamicAnimator。</p>

<h2>UIDynamicBehavior 是具体的物理行为。</h2>

<p>UIDynamicBehavior 赋予动态行为给一个或多个动态项（Dynamic Item）。</p>

<ul>
<li>UIDynamicBehavior 的主要方法和属性</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 在将要进行动画时的 block 回调</span>
</span><span class='line'><span class="k">@property</span><span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">copy</span><span class="p">)</span> <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">action</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 添加到该动态行为中的子动态行为</span>
</span><span class='line'><span class="k">@property</span><span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">readonly</span><span class="p">,</span> <span class="k">copy</span><span class="p">)</span> <span class="bp">NSArray</span> <span class="o">*</span><span class="n">childBehaviors</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//  该动态行为相关联的dynamicAnimator</span>
</span><span class='line'><span class="k">@property</span><span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">readonly</span><span class="p">)</span> <span class="bp">UIDynamicAnimator</span> <span class="o">*</span><span class="n">dynamicAnimator</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//添加一个子动态行为</span>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">addChildBehavior</span><span class="p">:(</span><span class="bp">UIDynamicBehavior</span> <span class="o">*</span><span class="p">)</span><span class="n">behavior</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 移除一个子动态行为</span>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">removeChildBehavior</span><span class="p">:(</span><span class="bp">UIDynamicBehavior</span> <span class="o">*</span><span class="p">)</span><span class="n">behavior</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 当该动态行为将要被添加到一个UIDynamicAnimator中时，这个方法会被调用。</span>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">willMoveToAnimator</span><span class="p">:(</span><span class="bp">UIDynamicAnimator</span> <span class="o">*</span><span class="p">)</span><span class="n">dynamicAnimator</span>
</span></code></pre></td></tr></table></div></figure>


<p>在开发中，大部分情况下使用 UIDynamicBehavior 的子类就足够了，因为UIKit 中已经有几个现成的模拟现实的 UIDynamicBehavior 类。</p>

<h3>UIDynamicBehavior的子类有：</h3>

<h4>UIGravityBehavior</h4>

<p>重力行为，可以指定重力的方向和大小。用gravityDirection指定一个向量，或者设置 angle 和 magnitude。</p>

<p>打开刚才的项目，DynamicDemo，在 ViewController.m 中添加如下代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidAppear:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">animated</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">super</span> <span class="nl">viewDidAppear</span><span class="p">:</span><span class="n">animated</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="bp">UIGravityBehavior</span> <span class="o">*</span><span class="n">gravity</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UIGravityBehavior</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithItems</span><span class="p">:</span><span class="l">@[</span><span class="nb">self</span><span class="p">.</span><span class="n">squareView</span><span class="l">]</span><span class="p">];</span> <span class="c1">// 创建一个重力行为</span>
</span><span class='line'>    <span class="n">gravity</span><span class="p">.</span><span class="n">gravityDirection</span> <span class="o">=</span> <span class="n">CGVectorMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// 在垂直向下方向 1000 点/平方秒 的速度</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">animator</span> <span class="nl">addBehavior</span><span class="p">:</span><span class="n">gravity</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>运行项目可以看到效果：</p>

<p><img src="http://vit0.com/images/posts/2014-03-08-uikit-dynamic-gravity.gif" alt="image" /></p>

<h3>UICollisionBehavior</h3>

<p>碰撞行为，指定一个边界，物体在到达这个边界的时候会发生碰撞行为。通过实现 UICollisionBehaviorDelegate 可以跟踪物体什么时候开始碰撞和结束碰撞。</p>

<p>现在将下面代码添加到<code>[self.animator addBehavior:gravity];</code>之后</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 创建碰撞行为</span>
</span><span class='line'><span class="bp">UICollisionBehavior</span> <span class="o">*</span><span class="n">collision</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UICollisionBehavior</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithItems</span><span class="p">:</span><span class="n">balls</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 指定 Reference view 的边界为可碰撞边界</span>
</span><span class='line'><span class="n">collision</span><span class="p">.</span><span class="n">translatesReferenceBoundsIntoBoundary</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// UICollisionBehaviorModeItems:item 只会和别的 item 发生碰撞；UICollisionBehaviorModeBoundaries：item 只和碰撞边界进行碰撞；UICollisionBehaviorModeEverything:item 和 item 之间会发生碰撞，也会和指定的边界发生碰撞。</span>
</span><span class='line'><span class="n">collision</span><span class="p">.</span><span class="n">collisionMode</span> <span class="o">=</span> <span class="n">UICollisionBehaviorModeEverything</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">animator</span> <span class="nl">addBehavior</span><span class="p">:</span><span class="n">collision</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在运行项目：</p>

<p><img src="http://vit0.com/images/posts/2014-03-08-uikit-dynamic-collision.gif" alt="image" /></p>

<p>UICollisionBehavior通过下面两个方法来添加碰撞边界，可以根据贝塞尔曲线或者一条直线生成碰撞边界。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addBoundaryWithIdentifier:</span><span class="p">(</span><span class="kt">id</span> <span class="o">&lt;</span><span class="bp">NSCopying</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">identifier</span> <span class="nf">forPath:</span><span class="p">(</span><span class="bp">UIBezierPath</span><span class="o">*</span><span class="p">)</span><span class="nv">bezierPath</span><span class="p">;</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addBoundaryWithIdentifier:</span><span class="p">(</span><span class="kt">id</span> <span class="o">&lt;</span><span class="bp">NSCopying</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">identifier</span> <span class="nf">fromPoint:</span><span class="p">(</span><span class="bp">CGPoint</span><span class="p">)</span><span class="nv">p1</span> <span class="nf">toPoint:</span><span class="p">(</span><span class="bp">CGPoint</span><span class="p">)</span><span class="nv">p2</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>UICollisionBehavior 里的 item 每次发生碰撞都可以通过 delegate 来监听事件。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// item 与 item 之间开始碰撞。</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">collisionBehavior:</span><span class="p">(</span><span class="bp">UICollisionBehavior</span><span class="o">*</span><span class="p">)</span><span class="nv">behavior</span> <span class="nf">beganContactForItem:</span><span class="p">(</span><span class="kt">id</span> <span class="o">&lt;</span><span class="bp">UIDynamicItem</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">item1</span> <span class="nf">withItem:</span><span class="p">(</span><span class="kt">id</span> <span class="o">&lt;</span><span class="bp">UIDynamicItem</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">item2</span> <span class="nf">atPoint:</span><span class="p">(</span><span class="bp">CGPoint</span><span class="p">)</span><span class="nv">p</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// item 与 item 之间结束碰撞。</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">collisionBehavior:</span><span class="p">(</span><span class="bp">UICollisionBehavior</span><span class="o">*</span><span class="p">)</span><span class="nv">behavior</span> <span class="nf">endedContactForItem:</span><span class="p">(</span><span class="kt">id</span> <span class="o">&lt;</span><span class="bp">UIDynamicItem</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">item1</span> <span class="nf">withItem:</span><span class="p">(</span><span class="kt">id</span> <span class="o">&lt;</span><span class="bp">UIDynamicItem</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">item2</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="c1">// item 和边界开始碰撞</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">collisionBehavior:</span><span class="p">(</span><span class="bp">UICollisionBehavior</span><span class="o">*</span><span class="p">)</span><span class="nv">behavior</span> <span class="nf">beganContactForItem:</span><span class="p">(</span><span class="kt">id</span> <span class="o">&lt;</span><span class="bp">UIDynamicItem</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">item</span> <span class="nf">withBoundaryIdentifier:</span><span class="p">(</span><span class="kt">id</span> <span class="o">&lt;</span><span class="bp">NSCopying</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">identifier</span> <span class="nf">atPoint:</span><span class="p">(</span><span class="bp">CGPoint</span><span class="p">)</span><span class="nv">p</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// item 和边界结束碰撞</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">collisionBehavior:</span><span class="p">(</span><span class="bp">UICollisionBehavior</span><span class="o">*</span><span class="p">)</span><span class="nv">behavior</span> <span class="nf">endedContactForItem:</span><span class="p">(</span><span class="kt">id</span> <span class="o">&lt;</span><span class="bp">UIDynamicItem</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">item</span> <span class="nf">withBoundaryIdentifier:</span><span class="p">(</span><span class="kt">id</span> <span class="o">&lt;</span><span class="bp">NSCopying</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">identifier</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>让我们为项目添加碰撞行为的 delegate ，修改 ViewController.m 为下面样子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="nc">ViewController</span> <span class="p">()</span> <span class="o">&lt;</span><span class="bp">UICollisionBehaviorDelegate</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">strong</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="bp">UIView</span> <span class="o">*</span><span class="n">squareView</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">strong</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="bp">UIDynamicAnimator</span> <span class="o">*</span><span class="n">animator</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">BeginnerViewController</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">super</span> <span class="n">viewDidLoad</span><span class="p">];</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">squareView</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UIView</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFrame</span><span class="p">:</span><span class="n">CGRectMake</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)];</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">squareView</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIColor</span> <span class="n">orangeColor</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">view</span> <span class="nl">addSubview</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">squareView</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">animator</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UIDynamicAnimator</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithReferenceView</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">view</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidAppear:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">animated</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">super</span> <span class="nl">viewDidAppear</span><span class="p">:</span><span class="n">animated</span><span class="p">];</span>
</span><span class='line'>    <span class="bp">UIGravityBehavior</span> <span class="o">*</span><span class="n">gravity</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UIGravityBehavior</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithItems</span><span class="p">:</span><span class="l">@[</span><span class="nb">self</span><span class="p">.</span><span class="n">squareView</span><span class="l">]</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">animator</span> <span class="nl">addBehavior</span><span class="p">:</span><span class="n">gravity</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="bp">UICollisionBehavior</span> <span class="o">*</span><span class="n">collision</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UICollisionBehavior</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithItems</span><span class="p">:</span><span class="l">@[</span><span class="nb">self</span><span class="p">.</span><span class="n">squareView</span><span class="l">]</span><span class="p">];</span>
</span><span class='line'>    <span class="n">collision</span><span class="p">.</span><span class="n">translatesReferenceBoundsIntoBoundary</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>    <span class="n">collision</span><span class="p">.</span><span class="n">collisionDelegate</span> <span class="o">=</span> <span class="nb">self</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">animator</span> <span class="nl">addBehavior</span><span class="p">:</span><span class="n">collision</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#pragma mark - UICollisionBehaviorDelegate</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">collisionBehavior:</span><span class="p">(</span><span class="bp">UICollisionBehavior</span><span class="o">*</span><span class="p">)</span><span class="nv">behavior</span> <span class="nf">beganContactForItem:</span><span class="p">(</span><span class="kt">id</span> <span class="o">&lt;</span><span class="bp">UIDynamicItem</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">item</span> <span class="nf">withBoundaryIdentifier:</span><span class="p">(</span><span class="kt">id</span> <span class="o">&lt;</span><span class="bp">NSCopying</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">identifier</span> <span class="nf">atPoint:</span><span class="p">(</span><span class="bp">CGPoint</span><span class="p">)</span><span class="nv">p</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">// 结束碰撞为 squareView 设置一个随机背景</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">squareView</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIColor</span> <span class="nl">colorWithRed</span><span class="p">:(</span><span class="kt">float</span><span class="p">)</span><span class="n">rand</span><span class="p">()</span> <span class="o">/</span> <span class="n">RAND_MAX</span>
</span><span class='line'>                                                      <span class="nl">green</span><span class="p">:(</span><span class="kt">float</span><span class="p">)</span><span class="n">rand</span><span class="p">()</span> <span class="o">/</span> <span class="n">RAND_MAX</span>
</span><span class='line'>                                                       <span class="nl">blue</span><span class="p">:(</span><span class="kt">float</span><span class="p">)</span><span class="n">rand</span><span class="p">()</span> <span class="o">/</span> <span class="n">RAND_MAX</span>
</span><span class='line'>                                                      <span class="nl">alpha</span><span class="p">:</span><span class="mi">1</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">collisionBehavior:</span><span class="p">(</span><span class="bp">UICollisionBehavior</span><span class="o">*</span><span class="p">)</span><span class="nv">behavior</span> <span class="nf">endedContactForItem:</span><span class="p">(</span><span class="kt">id</span> <span class="o">&lt;</span><span class="bp">UIDynamicItem</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">item</span> <span class="nf">withBoundaryIdentifier:</span><span class="p">(</span><span class="kt">id</span> <span class="o">&lt;</span><span class="bp">NSCopying</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">identifier</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">// 结束碰撞为 squareView 设置一个随机背景</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">squareView</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIColor</span> <span class="nl">colorWithRed</span><span class="p">:(</span><span class="kt">float</span><span class="p">)</span><span class="n">rand</span><span class="p">()</span> <span class="o">/</span> <span class="n">RAND_MAX</span>
</span><span class='line'>                                                      <span class="nl">green</span><span class="p">:(</span><span class="kt">float</span><span class="p">)</span><span class="n">rand</span><span class="p">()</span> <span class="o">/</span> <span class="n">RAND_MAX</span>
</span><span class='line'>                                                       <span class="nl">blue</span><span class="p">:(</span><span class="kt">float</span><span class="p">)</span><span class="n">rand</span><span class="p">()</span> <span class="o">/</span> <span class="n">RAND_MAX</span>
</span><span class='line'>                                                      <span class="nl">alpha</span><span class="p">:</span><span class="mi">1</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在运行项目将会看到如下效果：</p>

<p><img src="http://vit0.com/images/posts/2014-03-08-uikit-dynamic-collision-delegate.gif" alt="collision delegate" /></p>

<h3>UIAttachmentBehavior</h3>

<p>附着行为，让物体附着在某个点或另外一个物体上。可以设置附着点的到物体的距离，阻尼系数和振动频率等。</p>

<p>在 ViewController.m 的 <code>- (void)viewDidAppear:(BOOL)animated</code> 末尾添加如下代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="bp">UIAttachmentBehavior</span> <span class="o">*</span><span class="n">attachment</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UIAttachmentBehavior</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithItem</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">squareView</span> <span class="nl">attachedToAnchor</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">squareView</span><span class="p">.</span><span class="n">center</span><span class="p">];</span>
</span><span class='line'><span class="n">attachment</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
</span><span class='line'><span class="n">attachment</span><span class="p">.</span><span class="n">damping</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>
</span><span class='line'><span class="n">attachment</span><span class="p">.</span><span class="n">frequency</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">animator</span> <span class="nl">addBehavior</span><span class="p">:</span><span class="n">attachment</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>运行项目看到效果：</p>

<p><img src="http://vit0.com/images/posts/2014-03-08-uikit-dynamic-attachment.gif" alt="attachment" /></p>

<p><strong>属性详细说明</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// UIAttachmentBehaviorTypeAnchor类型的依赖行为的锚点，锚点与行为相关的动力动画的坐标系统有关。</span>
</span><span class='line'><span class="k">@property</span><span class="p">(</span><span class="k">readwrite</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="bp">CGPoint</span> <span class="n">anchorPoint</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 吸附行为的类型</span>
</span><span class='line'><span class="k">@property</span><span class="p">(</span><span class="k">readonly</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="n">UIAttachmentBehaviorType</span> <span class="n">attachedBehaviorType</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 描述吸附行为减弱的阻力大小</span>
</span><span class='line'><span class="k">@property</span><span class="p">(</span><span class="k">readwrite</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="n">CGFloat</span> <span class="n">damping</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 吸附行为震荡的频率</span>
</span><span class='line'><span class="k">@property</span><span class="p">(</span><span class="k">readwrite</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="n">CGFloat</span> <span class="n">frequency</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 与吸附行为相连的动态项目，当吸附行为类型是UIAttachmentBehaviorTypeItems时有2个元素，当吸附行为类型是UIAttachmentBehaviorTypeAnchor时只有一个元素。</span>
</span><span class='line'><span class="k">@property</span><span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">readonly</span><span class="p">,</span> <span class="k">copy</span><span class="p">)</span> <span class="bp">NSArray</span> <span class="o">*</span><span class="n">items</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 吸附行为中的两个吸附点之间的距离，通常用这个属性来调整吸附的长度，可以创建吸附行为之后调用。系统基于你创建吸附行为的方法来自动初始化这个长度</span>
</span><span class='line'><span class="k">@property</span><span class="p">(</span><span class="k">readwrite</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="n">CGFloat</span> <span class="n">length</span>
</span></code></pre></td></tr></table></div></figure>


<h3>UIDynamicItemBehavior</h3>

<p>物体属性，如密度、弹性系数、摩擦系数、阻力、转动阻力等。</p>

<p>接下来我们修改物体的物理属性，为了能看到这个效果，我们先删除 UIAttachmentBehavior 相关的代码，并在<code>- (void)viewDidAppear:(BOOL)animated</code> 末尾添加如下代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="bp">UIDynamicItemBehavior</span> <span class="o">*</span><span class="n">itemBehavior</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UIDynamicItemBehavior</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithItems</span><span class="p">:</span><span class="l">@[</span><span class="nb">self</span><span class="p">.</span><span class="n">squareView</span><span class="l">]</span><span class="p">];</span>
</span><span class='line'><span class="n">itemBehavior</span><span class="p">.</span><span class="n">elasticity</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">;</span> <span class="c1">// 改变弹性</span>
</span><span class='line'><span class="n">itemBehavior</span><span class="p">.</span><span class="n">allowsRotation</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span> <span class="c1">// 允许旋转</span>
</span><span class='line'><span class="p">[</span><span class="n">itemBehavior</span> <span class="nl">addAngularVelocity</span><span class="p">:</span><span class="mi">1</span> <span class="nl">forItem</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">squareView</span><span class="p">];</span> <span class="c1">// 让物体旋转</span>
</span><span class='line'>
</span><span class='line'><span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">animator</span> <span class="nl">addBehavior</span><span class="p">:</span><span class="n">itemBehavior</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在我们看到，方块的弹性变大了，并且伴随着旋转：</p>

<p><img src="http://vit0.com/images/posts/2014-03-08-uikit-dynamic-item.gif" alt="item behavior" /></p>

<p><strong>属性详细说明</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 弹力，通常设置 0~1 之间</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">readwrite</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="n">CGFloat</span> <span class="n">elasticity</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 摩擦力，0表示完全光滑无摩擦</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">readwrite</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="n">CGFloat</span> <span class="n">friction</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 密度，一个 100x100 points（1 point 在 retina 屏幕上等于2像素，在普通屏幕上为1像素。）大小的物体，密度1.0，在上面施加 1.0 的力，会产生 100 point/平方秒 的加速度。</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">readwrite</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="n">CGFloat</span> <span class="n">density</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 线性阻力，物体在移动过程中受到的阻力大小</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">readwrite</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="n">CGFloat</span> <span class="n">resistance</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 旋转阻力，物体旋转过程中的阻力大小</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">readwrite</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="n">CGFloat</span> <span class="n">angularResistance</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 是否允许旋转</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">readwrite</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="kt">BOOL</span> <span class="n">allowsRotation</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>UIPushBehavior</h3>

<p>对物体施加力，可以是持续性的力也可以是一次性的力。用一个向量(CGVector)来表示力的方向和大小。</p>

<p>这次我们通过手势来动态的为物体添加推力，首先注释重力行为的相关代码，然后在<code>- (void)viewDidAppear:(BOOL)animated</code> 末尾添加如下代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="bp">UITapGestureRecognizer</span> <span class="o">*</span><span class="n">viewTapGesture</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UITapGestureRecognizer</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTarget</span><span class="p">:</span><span class="nb">self</span> <span class="nl">action</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">tapViewHandler</span><span class="p">:)];</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">view</span> <span class="nl">addGestureRecognizer</span><span class="p">:</span><span class="n">viewTapGesture</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>在ViewController.m中添加方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">tapViewHandler:</span><span class="p">(</span><span class="bp">UITapGestureRecognizer</span> <span class="o">*</span><span class="p">)</span><span class="nv">gestureRecognizer</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="bp">UIPushBehavior</span> <span class="o">*</span><span class="n">push</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UIPushBehavior</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithItems</span><span class="p">:</span><span class="l">@[</span><span class="nb">self</span><span class="p">.</span><span class="n">squareView</span><span class="l">]</span> <span class="nl">mode</span><span class="p">:</span><span class="n">UIPushBehaviorModeInstantaneous</span><span class="p">];</span>
</span><span class='line'>    <span class="bp">CGPoint</span> <span class="n">location</span> <span class="o">=</span> <span class="p">[</span><span class="n">gestureRecognizer</span> <span class="nl">locationInView</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">view</span><span class="p">];</span>
</span><span class='line'>    <span class="bp">CGPoint</span> <span class="n">itemCenter</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">squareView</span><span class="p">.</span><span class="n">center</span><span class="p">;</span>
</span><span class='line'>    <span class="n">push</span><span class="p">.</span><span class="n">pushDirection</span> <span class="o">=</span> <span class="n">CGVectorMake</span><span class="p">((</span><span class="n">location</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">itemCenter</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="mi">100</span><span class="p">,</span> <span class="p">(</span><span class="n">location</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">itemCenter</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">/</span> <span class="mi">100</span><span class="p">);</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">animator</span> <span class="nl">addBehavior</span><span class="p">:</span><span class="n">push</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面代码会根据手指点击，生成一个由物体中心点指向点击位置的点的向量，通过设置UIPushBehavior的pushDirection让物体产生一个推向点击点的力。说得有点抽象，看看现实效果</p>

<p><img src="http://vit0.com/images/posts/2014-03-08-uikit-dynamic-push.gif" alt="push behavior" /></p>

<p><strong>主要的属性和方法</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 推力模式，UIPushBehaviorModeContinuous：持续型。UIPushBehaviorModeInstantaneous：一次性推力。</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">readonly</span><span class="p">)</span> <span class="n">UIPushBehaviorMode</span> <span class="n">mode</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 推力是否被激活，在激活状态下，物体才会受到推力效果</span>
</span><span class='line'><span class="k">@property</span><span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">readwrite</span><span class="p">)</span> <span class="kt">BOOL</span> <span class="n">active</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 推力的大小和方向</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">readwrite</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="bp">CGVector</span> <span class="n">pushDirection</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>UISnapBehavior</h3>

<p>将一个物体钉在某一点。它只有一个初始化方法和一个属性。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 根据 item 和 point 来确定一个 item 要被定到哪个点上。</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">initWithItem:</span><span class="p">(</span><span class="kt">id</span> <span class="o">&lt;</span><span class="bp">UIDynamicItem</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">item</span> <span class="nf">snapToPoint:</span><span class="p">(</span><span class="bp">CGPoint</span><span class="p">)</span><span class="nv">point</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 减震系数，范围在0.0~1.0</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">assign</span><span class="p">)</span> <span class="n">CGFloat</span> <span class="n">damping</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个就留给大家自己实验了。XD</p>

<h2>Demo</h2>

<p>整个 Demo 的代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="nc">ViewController</span> <span class="p">()</span> <span class="o">&lt;</span><span class="bp">UICollisionBehaviorDelegate</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">strong</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="bp">UIView</span> <span class="o">*</span><span class="n">squareView</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">strong</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="bp">UIDynamicAnimator</span> <span class="o">*</span><span class="n">animator</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">ViewController</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">super</span> <span class="n">viewDidLoad</span><span class="p">];</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">squareView</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UIView</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFrame</span><span class="p">:</span><span class="n">CGRectMake</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)];</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">squareView</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIColor</span> <span class="n">orangeColor</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">view</span> <span class="nl">addSubview</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">squareView</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">animator</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UIDynamicAnimator</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithReferenceView</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">view</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidAppear:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">animated</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">super</span> <span class="nl">viewDidAppear</span><span class="p">:</span><span class="n">animated</span><span class="p">];</span>
</span><span class='line'><span class="c1">//    UIGravityBehavior *gravity = [[UIGravityBehavior alloc] initWithItems:@[self.squareView]];</span>
</span><span class='line'><span class="c1">//    [self.animator addBehavior:gravity];</span>
</span><span class='line'>
</span><span class='line'>    <span class="bp">UICollisionBehavior</span> <span class="o">*</span><span class="n">collision</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UICollisionBehavior</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithItems</span><span class="p">:</span><span class="l">@[</span><span class="nb">self</span><span class="p">.</span><span class="n">squareView</span><span class="l">]</span><span class="p">];</span>
</span><span class='line'>    <span class="n">collision</span><span class="p">.</span><span class="n">translatesReferenceBoundsIntoBoundary</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>    <span class="n">collision</span><span class="p">.</span><span class="n">collisionDelegate</span> <span class="o">=</span> <span class="nb">self</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">animator</span> <span class="nl">addBehavior</span><span class="p">:</span><span class="n">collision</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 吸附于某一点，也可以吸附与某个实现了 UIDynamicItem 的对象</span>
</span><span class='line'><span class="c1">//    UIAttachmentBehavior *attachment = [[UIAttachmentBehavior alloc] initWithItem:self.squareView attachedToAnchor:self.squareView.center];</span>
</span><span class='line'><span class="c1">//    attachment.length = 50;</span>
</span><span class='line'><span class="c1">//    attachment.damping = 0.5;</span>
</span><span class='line'><span class="c1">//    attachment.frequency = 1;</span>
</span><span class='line'><span class="c1">//    [self.animator addBehavior:attachment];</span>
</span><span class='line'><span class="c1">//    [self addViewAtPoint:self.squareView.center];</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 物体属性：质量、摩擦、阻力等</span>
</span><span class='line'>    <span class="bp">UIDynamicItemBehavior</span> <span class="o">*</span><span class="n">itemBehavior</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UIDynamicItemBehavior</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithItems</span><span class="p">:</span><span class="l">@[</span><span class="nb">self</span><span class="p">.</span><span class="n">squareView</span><span class="l">]</span><span class="p">];</span>
</span><span class='line'>    <span class="n">itemBehavior</span><span class="p">.</span><span class="n">elasticity</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">;</span>
</span><span class='line'>    <span class="n">itemBehavior</span><span class="p">.</span><span class="n">allowsRotation</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>    <span class="n">itemBehavior</span><span class="p">.</span><span class="n">resistance</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="n">itemBehavior</span> <span class="nl">addAngularVelocity</span><span class="p">:</span><span class="mi">1</span> <span class="nl">forItem</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">squareView</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">animator</span> <span class="nl">addBehavior</span><span class="p">:</span><span class="n">itemBehavior</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="bp">UITapGestureRecognizer</span> <span class="o">*</span><span class="n">viewTapGesture</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UITapGestureRecognizer</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTarget</span><span class="p">:</span><span class="nb">self</span> <span class="nl">action</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">tapViewHandler</span><span class="p">:)];</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">view</span> <span class="nl">addGestureRecognizer</span><span class="p">:</span><span class="n">viewTapGesture</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">tapViewHandler:</span><span class="p">(</span><span class="bp">UITapGestureRecognizer</span> <span class="o">*</span><span class="p">)</span><span class="nv">gestureRecognizer</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="bp">UIPushBehavior</span> <span class="o">*</span><span class="n">push</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UIPushBehavior</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithItems</span><span class="p">:</span><span class="l">@[</span><span class="nb">self</span><span class="p">.</span><span class="n">squareView</span><span class="l">]</span> <span class="nl">mode</span><span class="p">:</span><span class="n">UIPushBehaviorModeInstantaneous</span><span class="p">];</span>
</span><span class='line'>    <span class="bp">CGPoint</span> <span class="n">location</span> <span class="o">=</span> <span class="p">[</span><span class="n">gestureRecognizer</span> <span class="nl">locationInView</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">view</span><span class="p">];</span>
</span><span class='line'>    <span class="bp">CGPoint</span> <span class="n">itemCenter</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">squareView</span><span class="p">.</span><span class="n">center</span><span class="p">;</span>
</span><span class='line'>    <span class="n">push</span><span class="p">.</span><span class="n">pushDirection</span> <span class="o">=</span> <span class="n">CGVectorMake</span><span class="p">((</span><span class="n">location</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">itemCenter</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="mi">100</span><span class="p">,</span> <span class="p">(</span><span class="n">location</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">itemCenter</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">/</span> <span class="mi">100</span><span class="p">);</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">animator</span> <span class="nl">addBehavior</span><span class="p">:</span><span class="n">push</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#pragma mark - Helper</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addViewAtPoint:</span><span class="p">(</span><span class="bp">CGPoint</span><span class="p">)</span><span class="nv">center</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="bp">UIView</span> <span class="o">*</span><span class="n">view</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UIView</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFrame</span><span class="p">:</span><span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)];</span>
</span><span class='line'>    <span class="n">view</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIColor</span> <span class="n">grayColor</span><span class="p">];</span>
</span><span class='line'>    <span class="n">view</span><span class="p">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">center</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">view</span> <span class="nl">addSubview</span><span class="p">:</span><span class="n">view</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#pragma mark - UICollisionBehaviorDelegate</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">collisionBehavior:</span><span class="p">(</span><span class="bp">UICollisionBehavior</span><span class="o">*</span><span class="p">)</span><span class="nv">behavior</span> <span class="nf">beganContactForItem:</span><span class="p">(</span><span class="kt">id</span> <span class="o">&lt;</span><span class="bp">UIDynamicItem</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">item</span> <span class="nf">withBoundaryIdentifier:</span><span class="p">(</span><span class="kt">id</span> <span class="o">&lt;</span><span class="bp">NSCopying</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">identifier</span> <span class="nf">atPoint:</span><span class="p">(</span><span class="bp">CGPoint</span><span class="p">)</span><span class="nv">p</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">squareView</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIColor</span> <span class="nl">colorWithRed</span><span class="p">:(</span><span class="kt">float</span><span class="p">)</span><span class="n">rand</span><span class="p">()</span> <span class="o">/</span> <span class="n">RAND_MAX</span>
</span><span class='line'>                                                      <span class="nl">green</span><span class="p">:(</span><span class="kt">float</span><span class="p">)</span><span class="n">rand</span><span class="p">()</span> <span class="o">/</span> <span class="n">RAND_MAX</span>
</span><span class='line'>                                                       <span class="nl">blue</span><span class="p">:(</span><span class="kt">float</span><span class="p">)</span><span class="n">rand</span><span class="p">()</span> <span class="o">/</span> <span class="n">RAND_MAX</span>
</span><span class='line'>                                                      <span class="nl">alpha</span><span class="p">:</span><span class="mi">1</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">collisionBehavior:</span><span class="p">(</span><span class="bp">UICollisionBehavior</span><span class="o">*</span><span class="p">)</span><span class="nv">behavior</span> <span class="nf">endedContactForItem:</span><span class="p">(</span><span class="kt">id</span> <span class="o">&lt;</span><span class="bp">UIDynamicItem</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">item</span> <span class="nf">withBoundaryIdentifier:</span><span class="p">(</span><span class="kt">id</span> <span class="o">&lt;</span><span class="bp">NSCopying</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">identifier</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">squareView</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIColor</span> <span class="nl">colorWithRed</span><span class="p">:(</span><span class="kt">float</span><span class="p">)</span><span class="n">rand</span><span class="p">()</span> <span class="o">/</span> <span class="n">RAND_MAX</span>
</span><span class='line'>                                                      <span class="nl">green</span><span class="p">:(</span><span class="kt">float</span><span class="p">)</span><span class="n">rand</span><span class="p">()</span> <span class="o">/</span> <span class="n">RAND_MAX</span>
</span><span class='line'>                                                       <span class="nl">blue</span><span class="p">:(</span><span class="kt">float</span><span class="p">)</span><span class="n">rand</span><span class="p">()</span> <span class="o">/</span> <span class="n">RAND_MAX</span>
</span><span class='line'>                                                      <span class="nl">alpha</span><span class="p">:</span><span class="mi">1</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<h2>现实中的使用场景</h2>

<ul>
<li>AlertView 弹出和隐藏</li>
</ul>


<p><img src="http://teehanlax.com.s3.amazonaws.com/wordpress/wp-content/uploads/alertView.gif" alt="alertview" /></p>

<p>图片来自<a href="http://www.teehanlax.com/blog/introduction-to-uikit-dynamics/">teehan+lax</a></p>

<ul>
<li>类似于系统通知的弹性效果，侧边栏菜单弹性效果</li>
</ul>


<p><img src="http://teehanlax.com.s3.amazonaws.com/wordpress/wp-content/uploads/buttonBounce.gif" alt="slide menu" /></p>

<p>图片来自<a href="http://www.teehanlax.com/blog/introduction-to-uikit-dynamics/">teehan+lax</a></p>

<ul>
<li>类似于系统 Message 信息拉动时的弹簧效果</li>
</ul>


<p><img src="http://www.objc.io/images/issue-5/springyCollectionView.gif" alt="spring collection view" /></p>

<p>图片来自<a href="http://www.objc.io/issue-5/collection-views-and-uidynamics.html">obj.io</a></p>

<ul>
<li>还有很多使用场景期待大家共同挖掘补充</li>
</ul>


<h2>总结</h2>

<p>UIKit Dynamic 为开发者提供了模拟现实的交互动画。</p>

<p>从例子中来看，使用 UIKit Dynamic 实际上真的很简单，只需要几行或者十几行代码就能写出很棒的模拟真实世界的交互效果。</p>

<p>UIKit Dynamic 是 UIKit 的一部分，这意味着使用它不需要添加其它额外的framework，所以如果应用只支持 iOS 7 以上，可以在项目中多多使用，让应用中的动画效果瞬间提升好几个档次。</p>

<h2>参考</h2>

<p>2013 WWDC</p>

<ul>
<li><a href="https://developer.apple.com/wwdc/videos/index.php?id=206">WWDC 2013 206: Getting Started with UIKit Dynamics</a></li>
<li><a href="https://developer.apple.com/wwdc/videos/index.php?id=206">WWDC 2013 221: Advanced Techniques with UIKit Dynamics</a></li>
</ul>


<p>Blog</p>

<ul>
<li><a href="http://www.shinobicontrols.com/blog/posts/2013/09/19/ios7-day-by-day-day-0-uikit-dynamics">iOS7 Day-by-Day :: Day 0 :: UIKit Dynamics</a></li>
<li><a href="http://www.raywenderlich.com/zh-hans/52617/uikit-%E5%8A%9B%E5%AD%A6%E6%95%99%E7%A8%8B">UIKit 力学教程</a></li>
<li><a href="http://www.teehanlax.com/blog/introduction-to-uikit-dynamics/">Introduction to UIKit Dynamics</a></li>
<li><a href="http://www.objc.io/issue-5/collection-views-and-uidynamics.html">UICollectionView + UIKit Dynamics</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2013年终总结]]></title>
    <link href="http://vit0.com/blog/2014/01/04/2013nian-zhong-zong-jie/"/>
    <updated>2014-01-04T17:49:00+08:00</updated>
    <id>http://vit0.com/blog/2014/01/04/2013nian-zhong-zong-jie</id>
    <content type="html"><![CDATA[<p>2013年就这么 Gone 了，不擅长写作的我也开始硬着头皮写年终总结了。</p>

<h2>关于学习</h2>

<p>翻出了一年前的暑假自己写的一年计划：<a href="http://thecoder.diandian.com/post/2012-08-31/40038818951">大四一整年的学习计划</a>。现在回过头来看，那时真是 Too Young Too Simple。</p>

<h3>以下是去年还年轻、不懂事时预计今年的学习计划：</h3>

<ul>
<li>C语言。多研究算法《C语言入门经典》</li>
<li>学习linux系统，以ubuntu为例。在linux上开发android，J2EE应用</li>
<li>学习vim编辑器的使用</li>
<li>ios的开发学习</li>
<li>html5。从sencha touch 框架入手</li>
<li>在这期间穿插学习Git和Github的使用，还有时间的话学习下mongoDB</li>
</ul>


<h3>以及2013年实际上学习的东西：</h3>

<p>上面的计划中除了 iOS 和 Git 其它几个都成功的打了酱油。</p>

<p>记得开始学习 iOS正好是一年前的一月份，从学习到正式开始用 iOS 开发生产，到现在正好1年。虽然做了一年的 iOS 但是还是觉得水平还在新手级别，可能算是个高级新手吧，基础的知识还没来得及学好，iOS7又多了一堆东西要学。这一年一直都在用 iPad Debug，前几天终于拿到自己的 iPhone，希望有了 iPhone 能更好的窃取优秀 app 的亮点 :D，2014年要有大进步！</p>

<p>这一年对我来说意义非凡，这一年学到的、看到的东西太多了，不断刷新我对程序世界的认知。主要是和 Sumi 的一群大神在一起，各种光环的加成下，各种能力都有被加成的感觉。</p>

<p>有一段时间很焦虑，想学很多东西，觉得自己知道的太少了，但是由于没有一个很好的时间规划和学习计划，那段时间一直学得很迷茫，东看一点西看一点最后什么都没沉淀下来。随着 iOS 学习的深入，发现很多概念和之前学的东西都是相通的，比如 iOS 的前端代码实际上和 Web 前端大的概念上是很像的，Autolayout 和 Android 中的Relativelayout很像。Objective-c 中的面向对象概念也能从 Java 中找到共通之处。慢慢觉得现在首要任务还是先精通一门，然后再触类旁通。</p>

<p>哦，不得不提的是，由于项目需求，今年研究了各种各样App的 API，快成了 API 专业户了&hellip;还为Moves 封装了 <a href="https://github.com/vitoziv/moves-ios-sdk">iOS 端的 API</a> ，偶尔收到写反馈和交流的邮件，算是今年比较意外的收获。</p>

<p>今年学的一些其它有用的东西：</p>

<ul>
<li>Octpress + github page 搭建博客</li>
<li>Git Work Flow，合理的 git 使用也是 sumier 一直关注的问题。</li>
<li>Unit Testing，在 Ruby 大神的指引下也开始在项目中注重测试了。</li>
<li>零零碎碎的学了点 CoffeeScript，Sass，Ruby，然后没怎么用很快就忘光了，不过倒是对这些东西有个大体的印象。</li>
</ul>


<h2>2013的生活</h2>

<p>2013年开始就完全离开学校在外面住了，一直和 sumi 的小伙伴们一起生活。</p>

<p><img src="http://vit0.com/images/posts/2014-01-04-1.jpg" alt="Sumi 1" style="width:505px;"/>
<img src="http://vit0.com/images/posts/2014-01-04-2.jpg" alt="Sumi 2" style="width:250px;"/>
<img src="http://vit0.com/images/posts/2014-01-04-3.jpg" alt="Sumi 3" style="width:250px;"/></p>

<p>在 sumi 的日子真的很棒，学会了煮咖啡，学会了养猫。Sumi 有着非常棒的分享网络，大家都乐于分享，每天总能发现一些好玩好用的东西。在下班后经常去很多地方吃好吃的，或者发现了好玩的东西可以在工作室里呆到很晚一直研究，有时候等到 BRT 都停运了才回去。还能周末去厦大游泳，玩游戏。不过这样的生活也只是维持到了毕业&hellip;.</p>

<p>然后是毕业季的到来，在学校里相处了4年的室友都各奔东西，吃货5人组也好久没有聚过餐了，以前一起跳舞的小伙伴早就毕业。大家聊天的话题也从上课、老师、图书馆和妹子转到了工作、薪资、结婚。说起来好像没了青春似的，好忧伤。</p>

<p>毕业之后雯子就来厦门了，我的单身汉生活也就这么被终结了。生活变得更有规律，家里环境也越来越好，比以前整洁干净很多。虽然少了些单身汉的自由，但是有了家的感觉。</p>

<h2>对自己的总结</h2>

<p>这一年学的多，总结少，博客也就写了两篇，把笔记写在 Evernote 里和发一篇 blog 区别还是很大的。要养成写博客的习惯还要继续努力啊！比较遗憾的是，今年其实有很多事情可以记录下来，一直没有意识去记录与总结，现在很多事情都想不起来了。</p>

<p>今年主要收获就是，学会了 iOS 开发，买了 Mac 和 iPhone。</p>

<h2>2014年计划</h2>

<p>主要目标就是提升 iOS 水平，能够专精才有时间和心思去做其它想做的事情</p>

<ul>
<li>多读 Programming Guide，每读一个写一篇总结。目标是一个月一篇总共12篇。</li>
<li>消化一下<a href="http://www.objc.io/">Objc.io</a>的文章，还有<a href="http://nshipster.com/">NSHipster</a>里面有很多 Tips 也希望能基本上浏览一遍</li>
<li><p>学习好英文。现在很多有点技术含量的英文文章还是很难看下去，等别人翻译，移动端估计都成 Html5的天下了&hellip;..住我隔壁的是个英语老师，她的建议是设一个目标，比如考托福雅思，这样有一个明确的目标会比较有动力。我觉得可以考虑试试..报个低端点的等级考试 XD</p></li>
<li><p>计划之外的加分项</p>

<ul>
<li>用 HTML5写一些 Web 程序。首先之前都是在学 Web 端的东西，现在都没有用，估计都快忘光了，感觉很可惜。我对 Web 是存在着真爱的！其次，从现在发展的尿性看，HTML 5不管能否干掉 Native App，它都有巨大的市场需求，适应未来变化的准备还是要做好。希望明年能有机会玩玩 Web</li>
<li>在 App Store 上线个小App。今年其实有很多 Idea，倒是都记了下来，不过每次等一天之后冷静下来再分析这个 Idea 都能找到这样那样的不可行之处&hellip;希望2014年能有个微型的 Idea 成功孵化。</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS学习之Autolayout]]></title>
    <link href="http://vit0.com/blog/2013/12/07/iosxue-xi-zhi-autolayout/"/>
    <updated>2013-12-07T09:54:00+08:00</updated>
    <id>http://vit0.com/blog/2013/12/07/iosxue-xi-zhi-autolayout</id>
    <content type="html"><![CDATA[<h1>学习资料</h1>

<h3>文章</h3>

<ul>
<li><a href="http://www.raywenderlich.com/50317/beginning-auto-layout-tutorial-in-ios-7-part-1">Beginning Auto Layout Tutorial in iOS 7: Part 1
</a></li>
<li><a href="http://www.raywenderlich.com/50319/beginning-auto-layout-tutorial-in-ios-7-part-2">Beginning Auto Layout Tutorial in iOS 7: Part 2</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG/Introduction/Introduction.html">Auto Layout Guide（官方）</a></li>
</ul>


<p>前两篇文章对如何在xcode 5中使用autolayout讲得已经很详细了。我使用了一段时间autolayout的感觉是，一般情况下都可以通过xcode的ib上直接设置autolayout的各种属性完成项目需求，除非遇到需求比较复杂的布局。</p>

<p>官方的Auto Layout Guide讲得详细易懂，推荐</p>

<h3>WWDC视频</h3>

<h4>2012</h4>

<ul>
<li><a href="https://developer.apple.com/videos/wwdc/2012/?id=202">202 – Introduction to Auto Layout for iOS and OS X</a></li>
<li><a href="">228 – Best Practices for Mastering Auto Layout</a></li>
<li><a href="https://developer.apple.com/videos/wwdc/2012/?id=232">232 – Auto Layout by Example</a></li>
<li><a href="http://www.objc.io/issue-3/advanced-auto-layout-toolbox.html">以及obj.io对这三个视频的总结</a></li>
</ul>


<h4>2013</h4>

<ul>
<li><a href="https://developer.apple.com/wwdc/videos/?include=406#406">Taking Control of Auto Layout in Xcode 5</a></li>
</ul>


<h1>一些学习到的知识点整理</h1>

<h2>用代码创建一个 NSLayoutConstraint</h2>

<p>下面的方法遵循一个计算公式：</p>

<p><strong><code>view1.attribute1 = multiplier × view2.attribute2 + constant</code></strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">constraintWithItem:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">view1</span>
</span><span class='line'>                 <span class="nf">attribute:</span><span class="p">(</span><span class="n">NSLayoutAttribute</span><span class="p">)</span><span class="nv">attribute1</span>
</span><span class='line'>                 <span class="nf">relatedBy:</span><span class="p">(</span><span class="n">NSLayoutRelation</span><span class="p">)</span><span class="nv">relation</span>
</span><span class='line'>                  <span class="nf">toItem:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">view2</span>
</span><span class='line'>               <span class="nf">attribute:</span><span class="p">(</span><span class="n">NSLayoutAttribute</span><span class="p">)</span><span class="nv">attribute2</span>
</span><span class='line'>              <span class="nf">multiplier:</span><span class="p">(</span><span class="n">CGFloat</span><span class="p">)</span><span class="nv">multiplier</span>
</span><span class='line'>                <span class="nf">constant:</span><span class="p">(</span><span class="n">CGFloat</span><span class="p">)</span><span class="nv">constant</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>例子：</p>

<ul>
<li>Button.centerX = Superview.centerX</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[</span><span class="bp">NSLayoutConstraint</span> <span class="nl">constraintWithItem</span><span class="p">:</span><span class="n">button</span>
</span><span class='line'>                           <span class="nl">attribute</span><span class="p">:</span><span class="n">NSLayoutAttributeCenterX</span>
</span><span class='line'>                             <span class="nl">relatedBy</span><span class="p">:</span><span class="n">NSLayoutRelationEqual</span>
</span><span class='line'>                                <span class="nl">toItem</span><span class="p">:</span><span class="n">superview</span>
</span><span class='line'>                             <span class="nl">attribute</span><span class="p">:</span><span class="n">NSLayoutAttributeCenterX</span>
</span><span class='line'>                            <span class="nl">multiplier</span><span class="p">:</span><span class="mf">1.0f</span>
</span><span class='line'>                              <span class="nl">constant</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Button.bottom = Superview.bottom - <padding></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[</span><span class="bp">NSLayoutConstraint</span> <span class="nl">constraintWithItem</span><span class="p">:</span><span class="n">button</span>
</span><span class='line'>                           <span class="nl">attribute</span><span class="p">:</span><span class="n">NSLayoutAttributeBottom</span>
</span><span class='line'>                             <span class="nl">relatedBy</span><span class="p">:</span><span class="n">NSLayoutRelationEqual</span>
</span><span class='line'>                                <span class="nl">toItem</span><span class="p">:</span><span class="n">superview</span>
</span><span class='line'>                             <span class="nl">attribute</span><span class="p">:</span><span class="n">NSLayoutAttributeBottom</span>
</span><span class='line'>                            <span class="nl">multiplier</span><span class="p">:</span><span class="mf">1.0f</span>
</span><span class='line'>                              <span class="nl">constant</span><span class="p">:</span><span class="o">-</span><span class="n">padding</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>创建完 NSLayoutConstraint 接下来要将它添加到 view 里，添加方法很简单，用 view 的<code>- (void)addConstraint:(NSLayoutConstraint *)constraint</code>添加。但是应该添加到哪个 view 里呢？</p>

<ol>
<li><p>兄弟 view 的 Constraint 添加到他们的 superview</p>

<p> <img src="http://vit0.com/images/posts/2013-12-07-Cousin-choose.png" title="兄弟 view 之间添加 Constraint 到 superview" alt="兄弟 view 之间添加 Constraint 到 superview" /></p></li>
<li><p>两个 view 的父 view 是兄弟关系的，Constraint 添加到父 view 的 superview 上</p>

<p> <img src="http://vit0.com/images/posts/2013-12-07-parent-cousin-choose.png" title="父 view 是兄弟关系的，Constraint 添加到父 view 的 superview 上" alt="父 view 是兄弟关系的，Constraint 添加到父 view 的 superview 上" /></p></li>
<li><p>如果两个 view 是 parent-child 关系，Constraint 添加到 parent view上</p>

<p> <img src="http://vit0.com/images/posts/2013-12-07-parent-child-choose.jpg" title="如果两个 view 是 parent-child 关系，Constraint 添加到 parent view上" alt="如果两个 view 是 parent-child 关系，Constraint 添加到 parent view上" /></p></li>
</ol>


<h2>跨层级 view 之间的 Constraint</h2>

<p>有如下的视图层级：</p>

<pre><code>- View
    - UIScrollView
        - UISwitch
    - UIButton
</code></pre>

<p>其中UISwitch相对 UIScrollView 水平居中，和 ScrollView 同一层级有一个 UIButton，现在要始终保持 UIButton 的水平中点位置和 UISwitch 的水平中点位置在同一条线上。</p>

<p>为 UISwitch 的水平居中 Constraint 建立一个 IBOutlet。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'> <span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">viewDidLoad</span> <span class="p">{</span>
</span><span class='line'>      <span class="p">[</span><span class="nb">super</span> <span class="n">viewDidLoad</span><span class="p">];</span>
</span><span class='line'>      <span class="c1">// Remove the IB-generated constraint centering the switch in its super view</span>
</span><span class='line'>      <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">scrollView</span> <span class="nl">removeConstraint</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">horizontalSwitchConstraint</span><span class="p">]</span>
</span><span class='line'>  
</span><span class='line'>      <span class="c1">// Add a new constraint centering the switch on the button</span>
</span><span class='line'>      <span class="bp">NSLayoutConstraint</span> <span class="o">*</span><span class="n">cn</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSLayoutConstraint</span> <span class="nl">constraintWithItem</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">switchButton</span>
</span><span class='line'>                                                          <span class="nl">attribute</span><span class="p">:</span><span class="n">NSLayoutAttributeCenterX</span>
</span><span class='line'>                                                          <span class="nl">relatedBy</span><span class="p">:</span><span class="n">NSLayoutRelationEqual</span>
</span><span class='line'>                                                             <span class="nl">toItem</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">button</span>
</span><span class='line'>                                                          <span class="nl">attribute</span><span class="p">:</span><span class="n">NSLayoutAttributeCenterX</span>
</span><span class='line'>                                                         <span class="nl">multiplier</span><span class="p">:</span><span class="mf">1.0f</span>
</span><span class='line'>                                                           <span class="nl">constant</span><span class="p">:</span><span class="mi">0</span><span class="p">];</span>
</span><span class='line'>      <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">view</span> <span class="nl">addConstraint</span><span class="p">:</span><span class="n">cn</span><span class="p">];</span> 
</span><span class='line'>  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的的代码就实现了跨层级视图之间的 Constraint 设置。其实就是这么简单</p>

<h2>设置Autolayout有两个原则</h2>

<ul>
<li><strong>Ambiguous Layout</strong>(The constraints must be suficient)</li>
<li><strong>Unsatisfiable Constraints</strong>(The constraints must not conflict)</li>
</ul>


<h2>在 IB 中设置明确的宽度</h2>

<p>设置宽度有几个原则：</p>

<ul>
<li>如果一个 View 的宽高在显示的时候是不确定的：让 view 根据内容改变大小（size to fit size）</li>
<li>如果一个 View 有确定的大小：改变其宽度的 Constraint Relation 为 >=</li>
<li>正确的设置<strong>Content Hugging Priority（内容压缩优先级）</strong> 与 <strong>Content Compression Resistance Priority（内容抗压缩优先级）</strong></li>
</ul>


<h3>Relation（Greater/Less） 与 Priority</h3>

<p>Greater/Less 一般与 Priority 一起使用，为一个 Constraint 设置了 Greater/Less 后，调整 Priority。如果 Constraint 的 Priority 的值越大，程序优先设置它的 Constraint 效果。</p>

<p>如果两个 View 不在同一个层级，此时想要设置他们之间的 Constraint，只能通过代码实现。简单的方式是：先在 Xcode 中设置了 Constraint，然后为这个 Constraint 建立一个 IBOutlet，回到代码中，移除想要替换的 Constraint。</p>

<h3>Content Hugging Priority 与 Content Compression Resistance Priority</h3>

<p>含义：</p>

<ul>
<li>Content Hugging Priority（内容压缩优先级）</li>
<li>Content Compression Resistance Priority（内容抗压缩优先级）。</li>
</ul>


<p>如果 Constraint 发生冲突时，会先找优先级高的UIView，满足优先级高的UIView 的Constraint 后再依次找优先级低的 Constraint 满足，最后改变 View 的 Frame。如果发生多个 Constraint不能同时满足的情况，就发生了<strong>Unsatisfiable Constraints</strong>的错误。</p>

<h2>Visual Format Language</h2>

<p>VFL(Visual Format Language),提供了一种让代码以一种可视化的方式来设置不同 views 之间的 Constraint。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'> <span class="p">[</span><span class="bp">NSLayoutConstraint</span> <span class="nl">constraintsWithVisualFormat</span><span class="p">:</span><span class="s">@&quot;[cancelButton]-[acceptButton]&quot;</span><span class="p">]</span> <span class="nl">options</span><span class="p">:</span><span class="mi">0</span> <span class="nl">metrics</span><span class="p">:</span><span class="nb">nil</span> <span class="nl">views</span><span class="p">:</span><span class="n">viewsDictionary</span><span class="p">];</span>
</span><span class='line'>  
</span><span class='line'>  <span class="bp">UIButton</span> <span class="o">*</span><span class="n">cancelButton</span> <span class="o">=</span> <span class="p">...</span>
</span><span class='line'>  <span class="bp">UIButton</span> <span class="o">*</span><span class="n">acceptButton</span> <span class="o">=</span> <span class="p">...</span>
</span><span class='line'>  <span class="n">viewsDictionary</span> <span class="o">=</span> <span class="n">NSDictionaryOfVariableBindings</span><span class="p">(</span><span class="n">cancelButton</span><span class="p">,</span> <span class="n">acceptButton</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>Examples:</strong></p>

<table>
<thead>
<tr>
<th>Property </th>
<th> Examples</th>
</tr>
</thead>
<tbody>
<tr>
<td>Inequality,Priority </td>
<td> [wideView(>=60@700)]</td>
</tr>
<tr>
<td>Vertical:Flush Views,Equal Heights </td>
<td> V:[redBox][yellowBox(==redBox)]</td>
</tr>
<tr>
<td>Combination </td>
<td> H:|-[Find]-[FindNext]-[FindField(>=20)]-</td>
</tr>
</tbody>
</table>


<p><img src="http://vit0.com/images/posts/2013-12-07-vfl01.png" title="Inequality,Priority" alt="Inequality,Priority" />
<img src="http://vit0.com/images/posts/2013-12-07-vfl02.png" title="Vertical:Flush Views,Equal Heights" alt="Vertical:Flush Views,Equal Heights" />
<img src="http://vit0.com/images/posts/2013-12-07-vfl03.png" title="Combination" alt="Combination" /></p>

<h2>Constraint 在什么时候更新</h2>

<p><img src="http://vit0.com/images/posts/2013-12-07-autolayout_phases_of_display.png" title="autolayout_phases_of_display" alt="autolayout_phases_of_display" /></p>

<p>UIView中</p>

<pre><code>-setNeesdDisplay
-setNeedsLayout
-setNeedsUpdateConstraints
</code></pre>

<p>UIView/UIWindow中</p>

<pre><code>-layoutIfNeeded
</code></pre>

<h2>关于 intrinsicContentSize</h2>

<p>在 UIView 中有个方法<code>-intrinsicContentSize</code>,用于指定一个 view 的 width 和 height，设置了<code>-intrinsicContentSize</code>相当于设置一个不可变的长度或者宽度。有点像 UISlider 只能设置宽度，不能设置高度那样。</p>

<h2>Debug</h2>

<ol>
<li><p>在 Xcode 中，设置 Autolayout 时可能出现3种状态，分别会出现黄色、红色、蓝色的线或线框。</p>

<ul>
<li>出现<strong>黄色</strong>的线或者线框表示：View 根据设置的 Constraints 最后计算出的 frame 位置和在xib 中 view 目前显示的位置不一致。此时并没有错误，只要更新一下 Update frames 以下就好</li>
<li>出现<strong>红色</strong>的线或者线框表示：出现了<strong>Ambiguous Layout</strong>（Constraints 太少以至不能确定一个 view 的位置）或者<strong>Unsatisfiable Constraints</strong>（Constraints 有冲突，确定 view 一个方向上的 Constraints 超过1个）。这种情况要找到没有正确设置 Constraints 的 View 添加缺失的 Constraints 或者删除多余的 Constraints。</li>
<li><strong>蓝色</strong>线条或者线框表示这个 view 的 Constraints 正确设置，并且 view 目前显示的位置和 Constraints 计算得出的最终位置是在同一个地方。</li>
</ul>
</li>
<li><p>在代码添加 Constraints 的 Debug 方法。</p>

<ul>
<li>在控制台输出AutolayoutTrace：<code>po [[UIWindow keyWindow] _autolayoutTrace]</code>。如果此时有<strong>Ambiguous Layout</strong>或<strong>Unsatisfiable Constraints</strong>，可以在输出的代码中看到。</li>
</ul>
</li>
<li><p>有用的 debugging defaults</p>

<ul>
<li>双倍的国际化字符串：<code>NSDoubleLocalizedStrings YES</code></li>
<li>显示视图的对齐框： <code>UIViewShowAlignmentRects YES</code></li>
</ul>
</li>
</ol>


<h2>AutoresizingMask自动转化成 Constraint</h2>

<p>view有一个 translatesAutoresizingMaskIntoConstraints 属性，如果设置为 NO，那么在运行时，程序不会自动将AutoresizingMask转化成 Constraint。</p>

<h2>Animation</h2>

<p>关键是在 UIView Animation 中调用<code>[view layoutIfNeeded]</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'> 
</span><span class='line'><span class="p">[</span><span class="n">UIview</span> <span class="nl">animateWithDuration</span><span class="p">:</span><span class="mf">1.0</span> <span class="nl">animations</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="c1">// Constraint Changed...</span>
</span><span class='line'>  
</span><span class='line'>  <span class="p">[</span><span class="n">view</span> <span class="n">layoutIfNeeded</span><span class="p">];</span>
</span><span class='line'><span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Github上一些好用的Autolayout第三方库</h2>

<ul>
<li><a href="https://github.com/cloudkite/Masonry">Masonry</a></li>
<li><a href="https://github.com/smileyborg/UIView-AutoLayout">UIView AutoLayout</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 之 UIScrollView 学习笔记]]></title>
    <link href="http://vit0.com/blog/2013/10/09/ios-zhi-uiscrollview-xue-xi-bi-ji/"/>
    <updated>2013-10-09T23:14:00+08:00</updated>
    <id>http://vit0.com/blog/2013/10/09/ios-zhi-uiscrollview-xue-xi-bi-ji</id>
    <content type="html"><![CDATA[<h1>使用场景</h1>

<p>在 iOS 中当屏幕装不下需要显示的内容时，就需要使用 Scroll views。使用Scroll views 有两个主要目的：</p>

<ul>
<li> 通过拖拽 Scroll views 的内容区域，让屏幕外的内容显示出来</li>
<li> 使用捏合手势（pinch gestures）让内容放大或者缩小</li>
</ul>


<h1>概览</h1>

<p> UIScrollView 类有这几个功能：</p>

<ul>
<li> 滑动 scroll view 中的内容</li>
<li> 缩放内容，通过手势放大缩小内容</li>
<li> 翻页模式</li>
</ul>


<p>UIScrollView的所有操作都是针对其subviews。</p>

<h1>基础UIScrollView</h1>

<p>实现一个最基础只有滑动功能的 UIScrollView 非常简单，必须步骤只有两个：</p>

<ol>
<li>设置 UIScrollView 的 contentSize 属性。这个属性代表可以滚动的区域大小。</li>
<li>在 UIScrollView 中添加子 view。子 view 提供显示的内容。</li>
</ol>


<p>还有一些可选项来完善 UIScrollView 比如 vertical and horizontal scroll indicators, drag bouncing, zoom bouncing, and directional constraint of scrolling。</p>

<p>在 UIScrollView 中添加一张很大的图片，然后实现拖动 UIScrollView 显示图片内容：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span> <span class="p">{</span>
</span><span class='line'>  <span class="p">[</span><span class="nb">super</span> <span class="n">viewDidLoad</span><span class="p">];</span>
</span><span class='line'>  <span class="bp">UIImage</span> <span class="o">*</span><span class="n">image</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIImage</span> <span class="nl">imageNamed</span><span class="p">:</span><span class="s">@&quot;test.jpg&quot;</span><span class="p">];</span>
</span><span class='line'>  <span class="bp">UIImageView</span> <span class="o">*</span><span class="n">imageView</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UIImageView</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithImage</span><span class="p">:</span><span class="n">image</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 1. 设置 UIScrollView 的 contentSize 属性。这个属性代表可以滚动的区域大小。</span>
</span><span class='line'>  <span class="nb">self</span><span class="p">.</span><span class="n">scrollView</span><span class="p">.</span><span class="n">contentSize</span> <span class="o">=</span> <span class="n">imageView</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 2. 在 UIScrollView 中添加子 view。子 view 提供显示的内容。</span>
</span><span class='line'>  <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">scrollView</span> <span class="nl">addSubview</span><span class="p">:</span><span class="n">imageView</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>设置contentInset，bouncing，滑动方向等都比较简单就略过之…</p>

<hr />

<p><strong>需要注意的是:</strong></p>

<pre><code>在设置UIScrollView的contentInset的时候，UIScrollView 的滚动条会变得很奇怪。
如果想让滚动条能正常显示应该同时设置scrollIndicatorInsets。

如：
self.scrollView.contentInset = UIEdgeInsetsMake(100, 0, 0, 0);
self.scrollView.scrollIndicatorInsets = UIEdgeInsetsMake(100, 0, 0, 0);
</code></pre>

<hr />

<h3>不用手势让 UIScrollView 滚起来</h3>

<p>我们可以：</p>

<ol>
<li><p><strong><code>setContentOffset:animated:</code></strong></p>

<ul>
<li><p>让 UIScrollView 滚到指定的偏移值（contentOffset），contentOffset 是一个 CGPoint，其中的 x,y 是屏幕左上角的那个点在 UIScrollView 的 content 中的坐标</p></li>
<li><p>如果 animated 传入的是 YES，UIScrollVIew 的 delegate 的<code>scrollViewDidScroll:</code>和<code>scrollViewDidEndScrollingAnimation:</code>方法都会收到消息。如果 animated 传入的是 NO，只有<code>scrollViewDidScroll:</code>方法会收到消息。</p></li>
</ul>
</li>
<li><p><strong><code>scrollRectToVisible:animated:</code></strong></p>

<ul>
<li>让 UIScrollView 滚动到指定的矩形区域可见位置</li>
<li>animated传入值对 delegate 的影响同上</li>
</ul>
</li>
<li><p><strong>点击屏幕状态栏 UIScrollView Scroll to top</strong></p>

<p> 可以在 delegate 的 <code>scrollViewShouldScrollToTop:</code>方法中设置是否开启这个功能。</p></li>
</ol>


<h1>UIScrollViewDelegate</h1>

<h3>UIScrollView 状态</h3>

<p>当UIScrollView 正在滑动的时候，以下几个状态属性会发生改变，UIScrollView 也正是通过这些状态来判断要让 delegate 发出什么消息。</p>

<p><em>表 1-1：UIScrollView 状态属性</em></p>

<table>
<thead>
<tr>
<th>State property </th>
<th> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>tracking       </td>
<td> YES if the user’s finger is in contact with the device screen.</td>
</tr>
<tr>
<td>dragging       </td>
<td> YES if the user’s finger is in contact with the device screen and has moved.</td>
</tr>
<tr>
<td>decelerating   </td>
<td> YES if the scroll view is decelerating as a result of a flick gesture, or a bounce from dragging beyond the scroll view frame.</td>
</tr>
<tr>
<td>zooming        </td>
<td> YES if the scroll view is tracking a pinch gesture to change its zoomScale property..</td>
</tr>
<tr>
<td>contentOffset  </td>
<td> A CGPoint value that defines the top-left corner of the scroll view bounds.</td>
</tr>
</tbody>
</table>


<h4>Delegate 方法的生命周期</h4>

<ol>
<li><code>tracking = YES</code></li>
<li><code>dragging = YES</code>，<code>scrollViewWillBeginDragging:</code></li>
<li>改变<code>contentOffset</code>，<code>scrollViewDidScroll:</code></li>
<li>手指离开 UIScrollView，<code>tracking = YES</code>，<code>scrollViewDidEndDragging:willDecelerate:</code></li>
<li>如果<code>decelerate = YES</code>,发送<code>scrollViewWillBeginDecelerating:</code>。否则直接到第6步</li>
<li><code>decelerating = NO</code>,<code>scrollViewDidEndDecelerating:</code>，所有步骤完成！</li>
</ol>


<p>知道了 delegate 在什么时候发送什么消息，我们就可以根据实际需求在特定的方法里写代码了。关于 UIScrollViewDelegate 的方法名表达的意思非常清楚。还有一些 delegate 方法是关于缩放（zoom）的生命周期的，其实原理和上面一样。只是第三步的<code>scrollViewDidScroll:</code>改成<code>scrollViewDidZoom</code>。</p>

<h1>支持放大缩小</h1>

<p>UIScrollView支持捏合手势放大缩小的关键：指定一个 View 作为放大缩小的对象。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">UIView</span> <span class="o">*</span><span class="p">)</span><span class="nf">viewForZoomingInScrollView:</span><span class="p">(</span><span class="bp">UIScrollView</span> <span class="o">*</span><span class="p">)</span><span class="nv">scrollView</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">self</span><span class="p">.</span><span class="n">imageView</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看出，每次放大缩小只有一个 view 会被放大缩小，如果只是放大缩小图片，使用 UIImageView 就可以了。如果需要缩放多个 view，就需要一个用一个 view的容器将这些 views 全包含进去。</p>

<h1>支持 pageMode</h1>

<p>设置 pageMode = YES 就可以看到一页一页滚动的效果，但是 pageMode 是在特定的场景下使用，并且代码也不只是<code>pageMode = YES</code>就完了。Apple 官方有一个非常好的代码例子：</p>

<p><a href="https://developer.apple.com/library/ios/samplecode/PageControl/Introduction/Intro.html#//apple_ref/doc/uid/DTS40007795">PageControl sample code</a></p>

<h1>UIScrollView 与 Autolayout</h1>

<p>在使用 autolayout 的情况下由于各个 View 之间的距离都是通过 NSLayoutConstraint 设置，这样就算改变 父 view 的 <code>bounds.orign</code>，子 view 也不会改变位置。</p>

<p>官方提供了<strong><em>两种方法</em></strong>让 UIScrolView 在 autolayout 下正常滚动：</p>

<h3>1. 将所有的子 view 嵌套在一个 UIView 中，让 UIScrollView 滚动这个 子 view</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span> <span class="p">{</span>
</span><span class='line'>  <span class="bp">UIView</span> <span class="o">*</span><span class="n">contentView</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">contentView</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UIView</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFrame</span><span class="p">:</span><span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">contentWidth</span><span class="p">,</span><span class="n">contentHeight</span><span class="p">)];</span>
</span><span class='line'>
</span><span class='line'>  <span class="p">[</span><span class="n">scrollView</span> <span class="nl">addSubview</span><span class="p">:</span><span class="n">contentView</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// DON&#39;T change contentView&#39;s translatesAutoresizingMaskIntoConstraints,</span>
</span><span class='line'>  <span class="c1">// which defaults to YES;</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// Set the content size of the scroll view to match the size of the content view:</span>
</span><span class='line'>  <span class="p">[</span><span class="n">scrollView</span> <span class="nl">setContentSize</span><span class="p">:</span><span class="n">CGMakeSize</span><span class="p">(</span><span class="n">contentWidth</span><span class="p">,</span><span class="n">contentHeight</span><span class="p">)];</span>
</span><span class='line'>
</span><span class='line'>   <span class="cm">/* the rest of your code here... */</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>  
</span></code></pre></td></tr></table></div></figure>


<h3>2.纯 Autolayout 方式</h3>

<p>To use the pure autolayout approach do the following:</p>

<ul>
<li>Set translatesAutoresizingMaskIntoConstraints to NO on all views involved.</li>
<li>Position and size your scroll view with constraints external to the scroll view.</li>
<li>Use constraints to lay out the subviews within the scroll view, being sure that the constraints tie to all four edges of the scroll view and do not rely on the scroll view to get their size.</li>
</ul>


<p>A simple example would be a large image view, which has an intrinsic content size derived from the size of the image. In the viewDidLoad method of your view controller, you would include code similar to the code shown in the listing below:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span> <span class="p">{</span>
</span><span class='line'>    <span class="bp">UIScrollView</span> <span class="o">*</span><span class="n">scrollView</span><span class="p">;</span>
</span><span class='line'>    <span class="bp">UIImageView</span> <span class="o">*</span><span class="n">imageView</span><span class="p">;</span>
</span><span class='line'>    <span class="bp">NSDictionary</span> <span class="o">*</span><span class="n">viewsDictionary</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Create the scroll view and the image view.</span>
</span><span class='line'>    <span class="n">scrollView</span>  <span class="o">=</span> <span class="p">[[</span><span class="bp">UIScrollView</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="n">imageView</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UIImageView</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Add an image to the image view.</span>
</span><span class='line'>    <span class="p">[</span><span class="n">imageView</span> <span class="nl">setImage</span><span class="p">:[</span><span class="bp">UIImage</span> <span class="nl">imageNamed</span><span class="p">:</span><span class="s">&quot;MyReallyBigImage&quot;</span><span class="p">]];</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Add the scroll view to our view.</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">view</span> <span class="nl">addSubview</span><span class="p">:</span><span class="n">scrollView</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Add the image view to the scroll view.</span>
</span><span class='line'>    <span class="p">[</span><span class="n">scrollView</span> <span class="nl">addSubview</span><span class="p">:</span><span class="n">imageView</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Set the translatesAutoresizingMaskIntoConstraints to NO so that the views autoresizing mask is not translated into auto layout constraints.</span>
</span><span class='line'>    <span class="n">scrollView</span><span class="p">.</span><span class="n">translatesAutoresizingMaskIntoConstraints</span>  <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'>    <span class="n">imageView</span><span class="p">.</span><span class="n">translatesAutoresizingMaskIntoConstraints</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Set the constraints for the scroll view and the image view.</span>
</span><span class='line'>    <span class="n">viewsDictionary</span> <span class="o">=</span> <span class="n">NSDictionaryOfVariableBindings</span><span class="p">(</span><span class="n">scrollView</span><span class="p">,</span> <span class="n">imageView</span><span class="p">);</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">view</span> <span class="nl">addConstraints</span><span class="p">:[</span><span class="bp">NSLayoutConstraint</span> <span class="nl">constraintsWithVisualFormat</span><span class="p">:</span><span class="s">@&quot;H:|[scrollView]|&quot;</span> <span class="nl">options</span><span class="p">:</span><span class="mi">0</span> <span class="nl">metrics</span><span class="p">:</span> <span class="mi">0</span> <span class="nl">viewsDictionary</span><span class="p">:</span><span class="n">viewsDictionary</span><span class="p">]];</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">view</span> <span class="nl">addConstraints</span><span class="p">:[</span><span class="bp">NSLayoutConstraint</span> <span class="nl">constraintsWithVisualFormat</span><span class="p">:</span><span class="s">@&quot;V:|[scrollView]|&quot;</span> <span class="nl">options</span><span class="p">:</span><span class="mi">0</span> <span class="nl">metrics</span><span class="p">:</span> <span class="mi">0</span> <span class="nl">viewsDictionary</span><span class="p">:</span><span class="n">viewsDictionary</span><span class="p">]];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">scrollView</span> <span class="nl">addConstraints</span><span class="p">:[</span><span class="bp">NSLayoutConstraint</span> <span class="nl">constraintsWithVisualFormat</span><span class="p">:</span><span class="s">@&quot;H:|[imageView]|&quot;</span> <span class="nl">options</span><span class="p">:</span><span class="mi">0</span> <span class="nl">metrics</span><span class="p">:</span> <span class="mi">0</span> <span class="nl">viewsDictionary</span><span class="p">:</span><span class="n">viewsDictionary</span><span class="p">]];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">scrollView</span> <span class="nl">addConstraints</span><span class="p">:[</span><span class="bp">NSLayoutConstraint</span> <span class="nl">constraintsWithVisualFormat</span><span class="p">:</span><span class="s">@&quot;V:|[imageView]|&quot;</span> <span class="nl">options</span><span class="p">:</span><span class="mi">0</span> <span class="nl">metrics</span><span class="p">:</span> <span class="mi">0</span> <span class="nl">viewsDictionary</span><span class="p">:</span><span class="n">viewsDictionary</span><span class="p">]];</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/* the rest of your code here... */</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h1>对 UIScrollView 的 content 的理解：</h1>

<ul>
<li>滚动、缩放都是相对于 ScrollView 中的内容的，相当于 ScrollView 是一个窗口，里面的内容被各种缩放、滚动改变位置，我们看到的窗口所在的位置没有发生改变，改变的只是里面的内容。</li>
<li>UIScrollView 中的缩放是缩放 contentSize</li>
<li>设置 UIScrollView 中子 View 的 frame 时，是相对于 UIScrollView 的 frame 的，和 contentSize 无关。</li>
</ul>


<hr />

<h1>Reference</h1>

<ul>
<li><a href="https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/UIScrollView_pg/Introduction/Introduction.html">Scroll View Programming Guide for iOS</a></li>
<li><a href="https://developer.apple.com/library/ios/technotes/tn2154/_index.html">UIScrollView And Autolayout</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[新的开始]]></title>
    <link href="http://vit0.com/blog/2013/08/02/first-one/"/>
    <updated>2013-08-02T07:56:00+08:00</updated>
    <id>http://vit0.com/blog/2013/08/02/first-one</id>
    <content type="html"><![CDATA[<p>前段时间尝试使用Hexo管理博客，但是Hexo的bug实在太多。果断放弃Hexo，开始使用octopress。
使用octopress的感觉还是很好的，官方文档也很全面，按照官方文档一部一部来就行了。</p>
]]></content>
  </entry>
  
</feed>
